//#define WITHORGCODE
using GMap.NET.Internals;
using GMap.NET.MapProviders;
using GMap.NET.ObjectModel;
using GMap.NET.Projections;
#if GMAP4SKIA
using SkiaSharp;
using SkiaSharp.Views.Forms;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.Drawing.System.Drawing;
using System.Drawing.Text;
using System.IO;
using System.Threading.Tasks;
using System.Windows.Forms;
using Xamarin.Essentials;
#else
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.Drawing.Text;
using System.IO;
using System.Windows.Forms;
#endif

#if GMAP4SKIA
namespace GMap.NET.Skia {
#else
namespace GMap.NET.WindowsForms {
#endif
   /// <summary>
   ///     GMap.NET control for Windows Forms
   /// </summary>
   public partial class GMapControl :
#if GMAP4SKIA
      SKCanvasView,
#else
      UserControl,
#endif
      IDisposable {

      public enum ScaleModes {
         /// <summary>
         ///     no scaling
         /// </summary>
         Integer,

         /// <summary>
         /// </summary>
         Fractional,
      }

      public enum MapScaleInfoPositions {
         Top,
         Bottom
      }


      #region Events

      #region EventArgs

      public class PositionChangedEventArgs {
         public readonly PointLatLng Point;

         public PositionChangedEventArgs(PointLatLng point) {
            Point = point;
         }
      }

      public class TileLoadCompleteEventArgs {
         public readonly long ElapsedMilliseconds;

         public TileLoadCompleteEventArgs(long elapsedMilliseconds) {
            ElapsedMilliseconds = elapsedMilliseconds;
         }
      }

      public class TileCacheProgressEventArgs {
         public readonly int TilesLeft;

         public TileCacheProgressEventArgs(int tilesLeft) {
            TilesLeft = tilesLeft;
         }
      }

      public class MapTypeChangedEventArgs {
         public readonly GMapProvider Provider;

         public MapTypeChangedEventArgs(GMapProvider provider) {
            Provider = provider;
         }
      }

      public class EmptyTileErrorEventArgs {
         public readonly int Zoom;
         public readonly GPoint Pos;

         public EmptyTileErrorEventArgs(int zoom, GPoint pos) {
            Zoom = zoom;
            Pos = pos;
         }
      }

      public class ExceptionThrownEventArgs {
         public readonly Exception Exception;

         public ExceptionThrownEventArgs(Exception exception) {
            Exception = exception;
         }
      }



      public class MapClickEventArgs {
         public readonly PointLatLng Point;

         public readonly MouseEventArgs Mea;

         public MapClickEventArgs(PointLatLng point, MouseEventArgs e) {
            Point = point;
            Mea = e;
         }
      }

      public class DrawExtendedEventArgs {
         public readonly float RenderTranform;
         public readonly Graphics Graphics;

         public DrawExtendedEventArgs(Graphics g, float rendertranform) {
            RenderTranform = rendertranform;
            Graphics = g;
         }
      }

      public class GMapMarkerEventArgs {
         public readonly GMapMarker Marker;

         public readonly MouseEventArgs Mea;

         public GMapMarkerEventArgs(GMapMarker marker, MouseEventArgs e) {
            Marker = marker;
            Mea = e;
         }
      }

      public class GMapTrackEventArgs {
         public readonly GMapTrack Track;

         public readonly MouseEventArgs Mea;

         public GMapTrackEventArgs(GMapTrack track, MouseEventArgs e) {
            Track = track;
            Mea = e;
         }
      }

      public class GMapPolygonEventArgs {
         public readonly GMapPolygon Polygon;

         public readonly MouseEventArgs Mea;

         public GMapPolygonEventArgs(GMapPolygon polygon, MouseEventArgs e) {
            Polygon = polygon;
            Mea = e;
         }
      }

      public class SelectionChangeEventArgs {
         public readonly RectLatLng Selection;

         public readonly bool ZoomToFit;

         public SelectionChangeEventArgs(RectLatLng selection, bool zoomToFit) {
            Selection = selection;
            ZoomToFit = zoomToFit;
         }
      }

      #endregion

      /// <summary>
      /// Core: occurs when current position is changed
      /// </summary>
      public event EventHandler<PositionChangedEventArgs> OnMapPositionChanged;

      /// <summary>
      /// Core: occurs on map drag
      /// </summary>
      public event EventHandler OnMapDrag;

      /// <summary>
      /// Core: occurs on map zoom changed
      /// </summary>
      public event EventHandler OnMapZoomChanged;

      /// <summary>
      /// Core: occurs when tile set is starting to load
      /// </summary>
      public event EventHandler OnMapTileLoadStart;

      /// <summary>
      /// Core: occurs on empty tile displayed
      /// </summary>
      public event EventHandler<EmptyTileErrorEventArgs> OnMapEmptyTileError;

      /// <summary>
      /// Core: occurs when tile set load is complete
      /// </summary>
      public event EventHandler<TileLoadCompleteEventArgs> OnMapTileLoadComplete;

      /// <summary>
      /// Core: occurs on map type changed
      /// </summary>
      public event EventHandler<MapTypeChangedEventArgs> OnMapTypeChanged;


      /// <summary>
      /// wenn der Zoom geändert wurde (NICHT <see cref="OnMapZoomChanged"/>! Das wird wird nur bei gazzahligen Änderungen aufgerufen.)
      /// </summary>
      public event EventHandler OnMapFracionalZoomChanged;

      /// <summary>
      ///   occurs when clicked on map.
      /// </summary>
      public event EventHandler<MapClickEventArgs> OnMapClick;

      /// <summary>
      ///     occurs when double clicked on map.
      /// </summary>
      public event EventHandler<MapClickEventArgs> OnMapDoubleClick;


      /// <summary>
      ///     occurs when clicked on marker
      /// </summary>
      public event EventHandler<GMapMarkerEventArgs> OnMapMarkerClick;

      /// <summary>
      ///     occurs when double clicked on marker
      /// </summary>
      public event EventHandler<GMapMarkerEventArgs> OnMapMarkerDoubleClick;

      /// <summary>
      ///     occurs on mouse enters marker area
      /// </summary>
      public event EventHandler<GMapMarkerEventArgs> OnMapMarkerEnter;

      /// <summary>
      ///     occurs on mouse leaves marker area
      /// </summary>
      public event EventHandler<GMapMarkerEventArgs> OnMapMarkerLeave;


      /// <summary>
      ///     occurs when clicked on track
      /// </summary>
      public event EventHandler<GMapTrackEventArgs> OnMapTrackClick;

      /// <summary>
      ///     occurs when double clicked on track
      /// </summary>
      public event EventHandler<GMapTrackEventArgs> OnMapTrackDoubleClick;

      /// <summary>
      ///     occurs on mouse enters track area
      /// </summary>
      public event EventHandler<GMapTrackEventArgs> OnMapTrackEnter;

      /// <summary>
      ///     occurs on mouse leaves track area
      /// </summary>
      public event EventHandler<GMapTrackEventArgs> OnMapTrackLeave;


      /// <summary>
      ///     occurs when clicked on polygon
      /// </summary>
      public event EventHandler<GMapPolygonEventArgs> OnMapPolygonClick;

      /// <summary>
      ///     occurs when double clicked on polygon
      /// </summary>
      public event EventHandler<GMapPolygonEventArgs> OnMapPolygonDoubleClick;

      /// <summary>
      ///     occurs on mouse enters Polygon area
      /// </summary>
      public event EventHandler<GMapPolygonEventArgs> OnMapPolygonEnter;

      /// <summary>
      ///     occurs on mouse leaves Polygon area
      /// </summary>
      public event EventHandler<GMapPolygonEventArgs> OnMapPolygonLeave;


      /// <summary>
      ///     occurs when mouse selection is changed
      /// </summary>
      public event EventHandler<SelectionChangeEventArgs> OnMapSelectionChange;

      /// <summary>
      ///     occurs when an exception is thrown inside the map control
      /// </summary>
      public event ExceptionThrown OnMapExceptionThrown;

#if GMAP4SKIA

      // Im Nicht-Windows-System ex. die folgenden Events noch nicht. Sie werden def. und bei Bedarf selbst ausgelöst.

      public event EventHandler<PaintEventArgs> Paint;

      public event EventHandler<MouseEventArgs> MouseClick;

      public event EventHandler<MouseEventArgs> MouseDoubleClick;

      /// <summary>
      /// Tritt ein, wenn sich der Mauszeiger über dem Steuerelement befindet und eine Maustaste gedrückt wird.
      /// </summary>
      public event EventHandler<MouseEventArgs> MouseDown;

      /// <summary>
      /// Tritt ein, wenn sich der Mauszeiger über dem Steuerelement befindet und eine Maustaste losgelassen wird.
      /// </summary>
      public event EventHandler<MouseEventArgs> MouseUp;

      /// <summary>
      /// Tritt ein, wenn der Mauszeiger über dem Steuerelement bewegt wird.
      /// </summary>
      public event EventHandler<MouseEventArgs> MouseMove;

      /// <summary>
      /// Tritt ein, wenn der Mauszeiger den Bereich des Steuerelements verlässt.
      /// </summary>
      public event EventHandler MouseLeave;

#endif

      #endregion

      #region Implementierung der IDisposable-Schnittstelle

      /// <summary>
      /// true, wenn schon ein Dispose() erfolgte
      /// </summary>
      bool _isdisposed = false;

      /// <summary>
      /// kann expliziet für das Objekt aufgerufen werden um interne Ressourcen frei zu geben
      /// </summary>
      public
#if !GMAP4SKIA
         new
#endif
         void Dispose() {
         Dispose(true);
         GC.SuppressFinalize(this);
      }

      /// <summary>
      /// überschreibt die Standard-Methode
      /// <para></para>
      /// </summary>
      /// <param name="notfromfinalizer">falls, wenn intern vom Finalizer aufgerufen</param>
      protected
#if !GMAP4SKIA
         override
#endif
         void Dispose(bool notfromfinalizer) {
         if (!_isdisposed) {            // bisher noch kein Dispose erfolgt
            if (notfromfinalizer) {          // nur dann alle managed Ressourcen freigeben

               MapOverlays.CollectionChanged -= overlays_CollectionChanged;

               foreach (var o in MapOverlays)
                  o.Dispose();

               MapOverlays.Clear();

               ClearBackBuffer();
               if (core != null &&
                   core.IsStarted)
                  core.OnMapClose();
               core.Dispose();


               //MapEmptyTileBordersPen.Dispose();
               //_emptyTileBrush.Dispose();
               //MapEmptyTileFont.Dispose();

               //MapScaleFont.Dispose();
               //MapScalePen.Dispose();

               //_selectedAreaFillBrush.Dispose();
               //MapSelectionPen.Dispose();

               //MapCenterPen.Dispose();

               //MapTileGridLinesPen.Dispose();
               //MapTileGridLinesFont.Dispose();

               //CenterFormat.Dispose();
               //BottomFormat.Dispose();
               //MapCopyrightFont.Dispose();

               //MapEmptyTileBorders.Dispose();

            }
            // jetzt immer alle unmanaged Ressourcen freigeben (z.B. Win32)

            _isdisposed = true;        // Kennung setzen, dass Dispose erfolgt ist

#if !GMAP4SKIA
            base.Dispose(notfromfinalizer);
#endif
         }
      }

      #endregion

      #region public Props / Vars

      public static int ThreadPoolSize {
         get => PublicCore.ThreadPoolSize;
         set => PublicCore.ThreadPoolSize = value;
      }

      /// <summary>
      /// current map center position (lat/lgn)
      /// </summary>
      [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
      [Browsable(false)]
      public PointLatLng MapPosition {
         get => core.Position;
         set {
            if (core.Position != value) {
               core.Position = value;
               if (core.IsStarted)
                  ForceUpdateOverlays();
            }
         }
      }

      /// <summary>
      ///     location of cache
      /// </summary>
      [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
      [Browsable(false)]
      public string MapCacheLocation {
         get {
#if !DESIGN
            return PublicCore.MapCacheLocation;
#else
            return string.Empty;
#endif
         }
         set {
#if !DESIGN
            PublicCore.MapCacheLocation = value;
#endif
         }
      }

      bool _isDragging = false;

      /// <summary>
      /// is user dragging map
      /// </summary>
      [Browsable(false)]
      public bool MapIsDragging {
         get => _isDragging;
      }

      /// <summary>
      /// gets current map view top/left coordinate, width in Lng, height in Lat
      /// </summary>
      [Browsable(false)]
      public RectLatLng MapViewArea {
         get {
            if (!MapIsRotated)
               return core.ViewArea;
            else if (core.Provider.Projection != null) {
               var p = MapFromLocalToLatLng(0, 0);
               var p2 = MapFromLocalToLatLng(Width, Height);
               return RectLatLng.FromLTRB(p.Lng, p.Lat, p2.Lng, p2.Lat);
            }
            return RectLatLng.Empty;
         }
      }

      [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
      [Browsable(false)]
      public GMapProvider MapProvider {
         get => core.Provider;
         set {
            if (core.Provider == null || !core.Provider.Equals(value)) {
               Log("MapType: " + core.Provider.Name + " -> " + value.Name);

               var viewarea = MapSelectedArea;

               if (viewarea != RectLatLng.Empty) {
                  MapPosition = new PointLatLng(viewarea.Lat - viewarea.HeightLat / 2,
                      viewarea.Lng + viewarea.WidthLng / 2);
               } else {
                  viewarea = MapViewArea;
               }

               core.Provider = value;

               if (core.IsStarted) {
                  if (core.ZoomToArea) {
                     // restore zoomrect as close as possible
                     if (viewarea != RectLatLng.Empty && viewarea != MapViewArea) {
                        int bestZoom = core.GetMaxZoomToFitRect(viewarea);
                        if (bestZoom > 0 && MapZoom != bestZoom) {
                           MapZoom = bestZoom;
                        }
                     }
                  } else {
                     ForceUpdateOverlays();
                  }
               }
            }
         }
      }

      /// <summary>
      /// can user drag map
      /// </summary>
      [Category("GMap.NET")]
      public bool MapCanDragMap {
         get => core.CanDragMap;
         set => core.CanDragMap = value;
      }

      ///// <summary>
      ///// map render mode
      ///// </summary>
      //[Browsable(false)]
      //public RenderMode MapRenderMode {
      //   get => Core.RenderMode;
      //   internal set => Core.RenderMode = value;
      //}

      [Category("GMap.NET")]
      [Description("map scale type")]
      public ScaleModes MapScaleMode { get; set; } = ScaleModes.Integer;

      /// <summary>
      /// zusätzlicher Vergrößerungsfaktor falls das Display eine zu hohe DPI hat (null oder 1.0 ...)
      /// </summary>
      [Browsable(false)]
      public float MapRenderZoom2RealDevice {
         get => _mapRenderZoom2RealDevice ?? 1;
         set {
            if (value == 1)
               _mapRenderZoom2RealDevice = null;
            else
               _mapRenderZoom2RealDevice = value;
         }
      }

      /// <summary>
      /// stops immediate marker/track/polygon invalidations;
      /// call Refresh to perform single refresh and reset invalidation state
      /// </summary>
      [Browsable(false)]
      internal bool HoldInvalidation;

      /// <summary>
      /// retry count to get tile
      /// </summary>
      [Browsable(false)]
      public int MapRetryLoadTile {
         get => core.RetryLoadTile;
         set => core.RetryLoadTile = value;
      }

      /// <summary>
      /// how many levels of tiles are staying decompresed in memory
      /// </summary>
      [Browsable(false)]
      public int MapLevelsKeepInMemory {
         get => core.LevelsKeepInMemory;
         set => core.LevelsKeepInMemory = value;
      }

      public static readonly bool IsDesignerHosted =
#if GMAP4SKIA
         // Damit wurde ursprünglich das Control im Design-Modus passiv gehalten. Jetzt fkt. allerdings der Debug-Modus damit nicht mehr.
         false;  // = Xamarin.Forms.DesignMode.IsDesignModeEnabled ???
#else
         LicenseManager.UsageMode == LicenseUsageMode.Designtime;
#endif

      double _zoomReal;

      /// <summary>
      /// akt. Zoom (exponentiell, d.h. +1 bedeutet Verdopplung)
      /// </summary>
      [Category("GMap.NET")]
      [DefaultValue(12)]
      public double MapZoom {
         get => _zoomReal;
         set {
            if (_zoomReal != value) {
               if (value > MapMaxZoom) {
                  _zoomReal = MapMaxZoom;
               } else if (value < MapMinZoom) {
                  _zoomReal = MapMinZoom;
               } else {
                  _zoomReal = value;
               }

               double remainder = value % 1;
               if (MapScaleMode == ScaleModes.Fractional && remainder != 0) {
                  //_extraZoom = 1 + remainder;
                  float scaleValue = (float)Math.Pow(2d, remainder);
                  _mapRenderTransform = scaleValue;

                  MapZoomStep = Convert.ToInt32(value - remainder);
               } else {
                  _mapRenderTransform = null;
                  _zoomReal = MapZoomStep = (int)Math.Floor(value);
               }

               if (core.IsStarted && !_isDragging) {
                  ForceUpdateOverlays();

                  OnMapFracionalZoomChanged?.Invoke(this, new EventArgs());
               }
            }
         }
      }

      /// <summary>
      /// (linearer) Zoomfaktor von <see cref="MapZoom"/> (bezogen auf <see cref="MapMinZoom"/>)
      /// </summary>
      [Category("GMap.NET")]
      public double MapZoomLinear {
         get => Math.Pow(2.0, MapZoom - MapMinZoom);
         set {
            if (value >= 1)
               MapZoom = Math.Log(value, 2) + MapMinZoom;
         }
      }

      /// <summary>
      /// min zoom
      /// </summary>
      [Category("GMap.NET")]
      [Description("minimum zoom level of map")]
      public int MapMinZoom {
         get => core.MinZoom;
         set => core.MinZoom = value;
      }

      /// <summary>
      /// max zoom
      /// </summary>
      [Category("GMap.NET")]
      [Description("maximum zoom level of map")]
      public int MapMaxZoom {
         get => core.MaxZoom;
         set => core.MaxZoom = value;
      }

      /// <summary>
      /// map zooming type for mouse wheel
      /// </summary>
      [Category("GMap.NET")]
      [Description("map zooming type for mouse wheel")]
      public MouseWheelZoomType MouseWheelZoomType {
         get => core.MouseWheelZoomType;
         set => core.MouseWheelZoomType = value;
      }

      ///// <summary>
      /////     enable map zoom on mouse wheel
      ///// </summary>
      //[Category("GMap.NET")]
      //[Description("enable map zoom on mouse wheel")]
      //public bool MouseWheelZoomEnabled {
      //   get => core.MouseWheelZoomEnabled;
      //   set => core.MouseWheelZoomEnabled = value;
      //}

      /// <summary>
      /// if true, selects area just by holding mouse and moving
      /// </summary>
      [Category("GMap.NET")]
      public bool MapDisableAltForSelection = false;

      /// <summary>
      /// map dragg button
      /// </summary>
      [Category("GMap.NET")]
      public MouseButtons MapDragButton = MouseButtons.Right;

      RectLatLng _selectedArea;

      /// <summary>
      /// current selected area in map
      /// </summary>
      [Browsable(false)]
      public RectLatLng MapSelectedArea {
         get => _selectedArea;
         set {
            _selectedArea = value;
            if (core.IsStarted)
               MapCoreInvalidate();
         }
      }

      [Browsable(false)]
      public RoutingProvider MapRoutingProvider {
         get {
            var dp = MapProvider as RoutingProvider;
            if (dp == null)
               dp = GMapProviders.OpenStreetMap as RoutingProvider; // use OpenStreetMap if provider does not implement routing
            return dp;
         }
      }

      [Browsable(false)]
      public DirectionsProvider MapDirectionsProvider {
         get {
            var dp = MapProvider as DirectionsProvider;
            if (dp == null)
               dp = GMapProviders.OpenStreetMap as DirectionsProvider; // use OpenStreetMap if provider does not implement routing
            return dp;
         }
      }

      [Browsable(false)]
      public GeocodingProvider MapGeocodingProvider {
         get {
            var dp = MapProvider as GeocodingProvider;
            if (dp == null)
               dp = GMapProviders.OpenStreetMap as GeocodingProvider; // use OpenStreetMap if provider does not implement routing
            return dp;
         }
      }

      [Browsable(false)]
      public RoadsProvider MapRoadsProvider {
         get {
            var dp = MapProvider as RoadsProvider;
            if (dp == null)
               dp = GMapProviders.GoogleMap as RoadsProvider; // use GoogleMap if provider does not implement routing
            return dp;
         }
      }

      /// <summary>
      /// is tracks enabled
      /// </summary>
      [Category("GMap.NET")]
      public bool MapTracksEnabled {
         get => core.RoutesEnabled; set => core.RoutesEnabled = value;
      }

      /// <summary>
      /// is polygons enabled
      /// </summary>
      [Category("GMap.NET")]
      public bool MapPolygonsEnabled {
         get => core.PolygonsEnabled; set => core.PolygonsEnabled = value;
      }

      /// <summary>
      /// is markers enabled
      /// </summary>
      [Category("GMap.NET")]
      public bool MapMarkersEnabled {
         get => core.MarkersEnabled; set => core.MarkersEnabled = value;
      }

      /// <summary>
      ///     returs true if map bearing is not zero
      /// </summary>
      [Browsable(false)]
      public bool MapIsRotated => core.IsRotated;

      /// <summary>
      ///     bearing for rotation of the map
      /// </summary>
      [Category("GMap.NET")]
      public float MapBearing {
         get => core.Bearing;
         set {
            if (core.Bearing != value) {
               bool resize = core.Bearing == 0;
               core.Bearing = value;

               //if(VirtualSizeEnabled)
               //{
               // c.X += (Width - Core.vWidth) / 2;
               // c.Y += (Height - Core.vHeight) / 2;
               //}

               updateRotationMatrix();

               if (value != 0 && value % 360 != 0) {
                  core.IsRotated = true;

                  if (core.TileRectBearing.Size == core.TileRect.Size) {
                     core.TileRectBearing = core.TileRect;
                     core.TileRectBearing.Inflate(1, 1);
                  }
               } else {
                  core.IsRotated = false;
                  core.TileRectBearing = core.TileRect;
               }

               if (resize) {
                  core.OnMapSizeChanged(Width, Height);
               }

               if (!HoldInvalidation && core.IsStarted) {
                  ForceUpdateOverlays();
               }
            }
         }
      }

      /// <summary>
      /// Ist der Mapservice bereit?
      /// </summary>
      public bool MapServiceIsReady => core != null && core.IsStarted;

      /// <summary>
      /// vervielfacht die scheinbare Trackbreite (bei 1 wird nur die echte Trackbreite verwendet)
      /// </summary>
      public float MapClickTolerance4Tracks { get; set; } = 1F;

      #region Def. einiger Anzeigen

      /// <summary>
      /// backgroundcolor for map
      /// </summary>
      [Category("GMap.NET")]
      public Color MapEmptyMapBackgroundColor { get; set; } = Color.WhiteSmoke;

      #region Def. der Darstellung für leere Tiles

      /// <summary>
      /// enables filling empty tiles using lower level images
      /// </summary>
      [Category("GMap.NET")]
      public bool MapFillEmptyTiles { get; set; } = true;

      /// <summary>
      /// text on empty tiles
      /// </summary>
      [Category("GMap.NET")]
      public string MapEmptyTileText { get; set; } = "no image";

      [Category("GMap.NET")]
      public Font MapEmptyTileFont = new Font(FontFamily.GenericSansSerif, 40, FontStyle.Bold);

      Color _emptyTileColor = Color.Navy;
      Brush _emptyTileBrush = new SolidBrush(Color.Navy);

      /// <summary>
      /// color of empty tile background
      /// </summary>
      [Category("GMap.NET")]
      [Description("background color of the empty tile")]
      public Color MapEmptyTileColor {
         get => _emptyTileColor;
         set {
            if (_emptyTileColor != value) {
               _emptyTileColor = value;

               if (_emptyTileBrush != null) {
                  _emptyTileBrush.Dispose();
                  _emptyTileBrush = null;
               }

               _emptyTileBrush = new SolidBrush(_emptyTileColor);
            }
         }
      }

      /// <summary>
      /// pen for empty tile borders
      /// </summary>
      [Category("GMap.NET")]
      public Pen MapEmptyTileBordersPen = new Pen(Brushes.White, 1);

      #endregion

      #region Def. für einfache Darstellung Maßstab

      /// <summary>
      /// Position of the map scale info
      /// </summary>
      [Category("GMap.NET")]
      protected MapScaleInfoPositions MapScaleInfoPosition { get; set; }

      /// <summary>
      /// Stift für Maßstab
      /// </summary>
      [Category("GMap.NET")]
      protected Pen MapScalePen = new Pen(Color.Black, 5);

      /// <summary>
      /// Stift für Maßstabumrandung
      /// </summary>
      [Category("GMap.NET")]
      protected Pen MapScalePenBorder = new Pen(Color.WhiteSmoke, 10);

      /// <summary>
      /// Font für die Beschriftung des Maßstabs
      /// </summary>
      [Category("GMap.NET")]
      protected Font MapScaleFont { get; set; } = new Font(FontFamily.GenericSansSerif, 35, FontStyle.Regular);

      #endregion

      #region Def. für Darstellung Auswahl

      /// <summary>
      /// area selection pen
      /// </summary>
      [Category("GMap.NET")]
      public Pen MapSelectionPen = new Pen(Brushes.Blue, 10);

      Brush _selectedAreaFillBrush = new SolidBrush(Color.FromArgb(33, Color.RoyalBlue));

      Color _selectedAreaFillColor = Color.FromArgb(33, Color.RoyalBlue);

      /// <summary>
      /// background of selected area
      /// </summary>
      [Category("GMap.NET")]
      [Description("background color od the selected area")]
      public Color MapSelectedAreaFillColor {
         get => _selectedAreaFillColor;
         set {
            if (_selectedAreaFillColor != value) {
               _selectedAreaFillColor = value;

               if (_selectedAreaFillBrush != null) {
                  _selectedAreaFillBrush.Dispose();
                  _selectedAreaFillBrush = null;
               }

               _selectedAreaFillBrush = new SolidBrush(_selectedAreaFillColor);
            }
         }
      }

      #endregion

      #region Def. für Grid-Linien

      bool _showTileGridLines = false;

      /// <summary>
      /// shows tile gridlines
      /// </summary>
      [Category("GMap.NET")]
      [Description("shows tile gridlines")]
      public bool MapShowTileGridLines {
         get {
            return _showTileGridLines;
         }
         set {
            _showTileGridLines = value;
            MapCoreInvalidate();
         }
      }

      /// <summary>
      /// pen for empty tile borders
      /// </summary>
      [Category("GMap.NET")]
      public Pen MapTileGridLinesPen = new Pen(Brushes.White, 5);

      [Category("GMap.NET")]
      public Font MapTileGridLinesFont = new Font(FontFamily.GenericSansSerif,
#if GMAP4SKIA
                                                  35,
#else
                                                  7,
#endif
                                                  FontStyle.Bold);

      #endregion

      [Category("GMap.NET")]
      public Font MapCopyrightFont { get; set; } = new Font(FontFamily.GenericSansSerif,
#if GMAP4SKIA
                                              35,
#else
                                              7,
#endif
                                              FontStyle.Regular);

      #endregion

      #endregion

      #region internal Props / Vars

      bool _isMouseOverMarker;
      int _overObjectCount;

      /// <summary>
      /// is mouse over marker
      /// </summary>
      [Browsable(false)]
      internal bool MapIsMouseOverMarker {
         get => _isMouseOverMarker;
         set {
            _isMouseOverMarker = value;
            _overObjectCount += value ? 1 : -1;
         }
      }

      bool _isMouseOverTrack;

      /// <summary>
      /// is mouse over track
      /// </summary>
      [Browsable(false)]
      internal bool MapIsMouseOverTrack {
         get => _isMouseOverTrack;
         set {
            _isMouseOverTrack = value;
            _overObjectCount += value ? 1 : -1;
         }
      }

      bool _isMouseOverPolygon;

      /// <summary>
      /// is mouse over polygon
      /// </summary>
      [Browsable(false)]
      internal bool MapIsMouseOverPolygon {
         get => _isMouseOverPolygon;
         set {
            _isMouseOverPolygon = value;
            _overObjectCount += value ? 1 : -1;
         }
      }

      internal long CoreRenderOffsetX => core.RenderOffset.X;

      internal long CoreRenderOffsetY => core.RenderOffset.Y;

      #endregion

      #region protected and privat Props / Vars

      protected int MapZoomStep {
         get => core.Zoom;
         set => core.Zoom = value;
      }

      bool _forTestShowCoreData = false;

      /// <summary>
      /// nur für Test: zeigt einige akt. Daten des Core auf dem Bildschirm an
      /// </summary>
      [Browsable(false)]
      protected bool mapForTestShowCoreData {
         get => _forTestShowCoreData;
         set {
            if (_forTestShowCoreData != value) {
               _forTestShowCoreData = value;
               MapCoreInvalidate();
            }
         }
      }

      /// <summary>
      /// Stift für Mittelpunktmarkierung
      /// </summary>
      [Category("GMap.NET")]
      protected Pen mapCenterPen = new Pen(Color.Red,
#if GMAP4SKIA
         5
#else
         1
#endif
         );

      //#if !GMAP4SKIA
      //      ColorMatrix _colorMatrix;

      //      protected ColorMatrix MapColorMatrix {
      //         get => _colorMatrix;
      //         set {
      //            _colorMatrix = value;
      //            if (GMapImageProxy.TileImageProxy != null && GMapImageProxy.TileImageProxy is GMapImageProxy) {
      //               (GMapImageProxy.TileImageProxy as GMapImageProxy).ColorMatrix = value;
      //               if (Core.IsStarted) {
      //                  MapReload();
      //               }
      //            }
      //         }
      //      }
      //#endif

      /// <summary>
      /// map boundaries
      /// </summary>
      RectLatLng? boundsOfMap = null;

      /// <summary>
      /// enables integrated DoubleBuffer for running on windows mobile
      /// </summary>
      bool mapForceDoubleBuffer;

      /// <summary>
      /// shrinks map area, useful just for testing
      /// </summary>
      bool mapVirtualSizeEnabled {
         get => core.VirtualSizeEnabled;
         set => core.VirtualSizeEnabled = value;
      }

      /// <summary>
      /// prevents focusing map if mouse enters it's area
      /// </summary>
      bool mapDisableFocusOnMouseEnter = false;

      /// <summary>
      /// reverses MouseWheel zooming direction
      /// </summary>
      bool mapInvertedMouseWheelZooming = false;

      /// <summary>
      /// lets you zoom by MouseWheel even when pointer is in area of marker
      /// </summary>
      bool mapIgnoreMarkerOnMouseWheel = false;

      /// <summary>
      /// Zusätzliche Skalierung zu <see cref="MapZoom"/> (null oder 1.0..2.0)?
      /// </summary>
      float? _mapRenderTransform;

      /// <summary>
      /// zusätzlicher Vergrößerungsfaktor falls das Display eine zu hohe DPI hat (null oder 1.0 ...)
      /// </summary>
      float? _mapRenderZoom2RealDevice = null;

      protected float MapRenderTransform => _mapRenderTransform ?? 1;

      /// <summary>
      /// gets map manager (<see cref="GMaps.Instance"/>)
      /// </summary>
      [Browsable(false)]
      protected GMaps MapManager => GMaps.Instance;

      bool mobileMode = false;

      /// <summary>
      /// list of overlays, should be thread safe
      /// </summary>
      protected readonly ObservableCollectionThreadSafe<GMapOverlay> MapOverlays = new ObservableCollectionThreadSafe<GMapOverlay>();

      PointLatLng selectionStart;
      PointLatLng selectionEnd;

      readonly Font missingDataFont = new Font(FontFamily.GenericSansSerif, 11, FontStyle.Bold);
      readonly Font scaleFont = new Font(FontFamily.GenericSansSerif, 7, FontStyle.Regular);
      readonly StringFormat centerFormat = new StringFormat();
      readonly StringFormat bottomFormat = new StringFormat();
      readonly Matrix rotationMatrix = new Matrix();
      readonly Matrix rotationMatrixInvert = new Matrix();
      bool isSelected;

#if !GMAP4SKIA
      readonly ImageAttributes tileFlipXYAttributes = new ImageAttributes();
      Cursor cursorBefore = Cursors.Default;
#else
      Cursor cursorBefore = null;
#endif

#if GMAP4SKIA
      /// <summary>
      /// Gets the width and height of a rectangle centered on the point the mouse button was pressed, within which a drag operation will not begin.
      /// </summary>
      Size dragSize = new Size(5, 5);
#else
      /// <summary>
      /// Gets the width and height of a rectangle centered on the point the mouse button was pressed, within which a drag operation will not begin.
      /// </summary>
      Size dragSize = SystemInformation.DragSize;
#endif

      Graphics graphicsBackBuffer = null;

      readonly PublicCore core = new PublicCore();

      #endregion


      static GMapControl() {
         if (!IsDesignerHosted) {
            GMapImageProxy.Enable();
            GMaps.Instance.SQLitePing();
         }
      }

#if !DESIGN
      public GMapControl() {
         if (!IsDesignerHosted) {
#if GMAP4SKIA
            core.SystemType = "SkiaAndroid";
            Font = new Font("Arial", 35);
#else
            SetStyle(ControlStyles.OptimizedDoubleBuffer, true);
            SetStyle(ControlStyles.AllPaintingInWmPaint, true);
            SetStyle(ControlStyles.UserPaint, true);
            SetStyle(ControlStyles.Opaque, true);
            ResizeRedraw = true;

            tileFlipXYAttributes.SetWrapMode(WrapMode.TileFlipXY);

            centerFormat.Alignment = StringAlignment.Center;
            centerFormat.LineAlignment = StringAlignment.Center;
            bottomFormat.Alignment = StringAlignment.Center;
            bottomFormat.LineAlignment = StringAlignment.Far;

            if (GMaps.Instance.IsRunningOnMono) // no imports to move pointer
               MouseWheelZoomType = MouseWheelZoomType.MousePositionWithoutCenter;

#endif

            core.OnCurrentPositionChanged += Core_OnCurrentPositionChanged;
            core.OnEmptyTileError += Core_OnEmptyTileError;
            core.OnMapDrag += Core_OnMapDrag;
            core.OnMapTypeChanged += Core_OnMapTypeChanged;
            core.OnMapZoomChanged += Core_OnMapZoomChanged;
            core.OnTileLoadComplete += Core_OnTileLoadComplete;
            core.OnTileLoadStart += Core_OnTileLoadStart;

            MapOverlays.CollectionChanged += overlays_CollectionChanged;
         }
      }

#endif

      #region Umsetzung der Core-Events

      private void Core_OnTileLoadStart() {
         OnMapTileLoadStart?.Invoke(this, EventArgs.Empty);
      }

      private void Core_OnTileLoadComplete(long elapsedMilliseconds) {
         OnMapTileLoadComplete?.Invoke(this, new TileLoadCompleteEventArgs(elapsedMilliseconds));
      }

      private void Core_OnMapZoomChanged() {
         OnMapZoomChanged?.Invoke(this, EventArgs.Empty);
      }

      private void Core_OnMapTypeChanged(GMapProvider type) {
         OnMapTypeChanged?.Invoke(this, new MapTypeChangedEventArgs(type));
      }

      private void Core_OnMapDrag() {
         OnMapDrag?.Invoke(this, EventArgs.Empty);
      }

      private void Core_OnEmptyTileError(int zoom, GPoint pos) {
         OnMapEmptyTileError?.Invoke(this, new EmptyTileErrorEventArgs(zoom, pos));
      }

      private void Core_OnCurrentPositionChanged(PointLatLng point) {
         OnMapPositionChanged?.Invoke(this, new PositionChangedEventArgs(point));
      }

      #endregion

      #region Event-Funktionen

#if !GMAP4SKIA
      protected override void OnMouseDown(MouseEventArgs e) {
         base.OnMouseDown(e);
#else
      protected void OnMouseDown(MouseEventArgs e) {
         MouseDown?.Invoke(this, e);
#endif
         if (!MapIsMouseOverMarker) {
            if (e.Button == MapDragButton && MapCanDragMap) {
               core.MouseDown = applyRotationInversion(e.X, e.Y);
               MapCoreInvalidate();
            } else if (!isSelected) {
               isSelected = true;
               MapSelectedArea = RectLatLng.Empty;
               selectionEnd = PointLatLng.Empty;
               selectionStart = MapFromLocalToLatLng(e.X, e.Y);
            }
         }
      }

#if !GMAP4SKIA
#else
#endif

#if !GMAP4SKIA
      protected override void OnMouseUp(MouseEventArgs e) {
         base.OnMouseUp(e);
#else
      protected void OnMouseUp(MouseEventArgs e) {
         MouseUp?.Invoke(this, e);
#endif
         isSelected = false;

         if (core.IsDragging) {
            if (_isDragging) {
               _isDragging = false;
#if !GMAP4SKIA
               Cursor = cursorBefore;
               cursorBefore = null;
#endif
            }

            core.EndDrag();

            if (boundsOfMap.HasValue &&
                !boundsOfMap.Value.Contains(MapPosition) &&
                core.LastLocationInBounds.HasValue)
               MapPosition = core.LastLocationInBounds.Value;

            //////////////////////////////////////////////////////////
            float scale = getScale();
            if (Math.Floor(scale) != scale)
               MapPosition = MapFromLocalToLatLng(Width / 2, Height / 2);   // Bei nichtganzzahligem Zoom ist eine Korrektur nötig!
            //////////////////////////////////////////////////////////

         } else {
            if (e.Button == MapDragButton)
               core.MouseDown = GPoint.Empty;

            if (!selectionEnd.IsEmpty &&
                !selectionStart.IsEmpty) {
               bool zoomtofit = false;

               if (!MapSelectedArea.IsEmpty && ModifierKeys == Keys.Shift)
                  zoomtofit = MapSetZoomToFitRect(MapSelectedArea);

               OnMapSelectionChange?.Invoke(this, new SelectionChangeEventArgs(MapSelectedArea, zoomtofit));
            } else {
               MapCoreInvalidate();
            }
         }
      }

#if !GMAP4SKIA
      protected override void OnMouseClick(MouseEventArgs e) {
         base.OnMouseClick(e);
         _onMouseClick(e, false, false, out _, out _, out _);
      }
#else
      PointLatLng OnMouseClick(MouseEventArgs e,
                               bool all,
                               out List<GMapMarker> markers,
                               out List<GMapTrack> tracks,
                               out List<GMapPolygon> polygons) {
         MouseClick?.Invoke(this, e);
         return _onMouseClick(e,
                              false,
                              all,
                              out markers,
                              out tracks,
                              out polygons);
      }
#endif

      /// <summary>
      /// liefert die Objektlisten an der Position und löst für die betroffenen Objekte die Click-Events aus
      /// </summary>
      /// <param name="e"></param>
      /// <param name="doubleclick"></param>
      /// <param name="all"></param>
      /// <param name="markers"></param>
      /// <param name="tracks"></param>
      /// <param name="polygons"></param>
      /// <returns></returns>
      PointLatLng _onMouseClick(MouseEventArgs e,
                                bool doubleclick,
                                bool all,
                                out List<GMapMarker> markers,
                                out List<GMapTrack> tracks,
                                out List<GMapPolygon> polygons) {
         GPoint rp = core.FromClientToGlobal(e.X, e.Y);

         PointLatLng point = PointLatLng.Empty;
         markers = new List<GMapMarker>();
         tracks = new List<GMapTrack>();
         polygons = new List<GMapPolygon>();

         if (!core.IsDragging) {
            bool overlayObject = false;

            for (int i = MapOverlays.Count - 1; i >= 0; i--) {
               var o = MapOverlays[i];

               if (o != null && o.IsVisibile && o.IsHitTestVisible) {

                  List<GMapMarker> markers4o = new List<GMapMarker>(getMarkers4Point(o, rp, all));
                  List<GMapTrack> tracks4o = new List<GMapTrack>(getTracks4Point(o, rp, all, MapClickTolerance4Tracks));
                  List<GMapPolygon> polygons4o = new List<GMapPolygon>(getPolygons4Point(o, e.X, e.Y, all));

                  markers.AddRange(markers4o);
                  tracks.AddRange(tracks4o);
                  polygons.AddRange(polygons4o);

                  foreach (var m in markers4o) {
                     if (doubleclick)
                        OnMapMarkerDoubleClick?.Invoke(this, new GMapMarkerEventArgs(m, e));
                     else
                        OnMapMarkerClick?.Invoke(this, new GMapMarkerEventArgs(m, e));
                  }

                  foreach (var t in tracks4o) {
                     if (doubleclick)
                        OnMapTrackDoubleClick?.Invoke(this, new GMapTrackEventArgs(t, e));
                     else
                        OnMapTrackClick?.Invoke(this, new GMapTrackEventArgs(t, e));
                  }

                  foreach (var p in polygons4o) {
                     if (doubleclick)
                        OnMapPolygonDoubleClick?.Invoke(p, new GMapPolygonEventArgs(p, e));
                     else
                        OnMapPolygonClick?.Invoke(p, new GMapPolygonEventArgs(p, e));
                  }

               }
               overlayObject = markers.Count > 0 || tracks.Count > 0 || polygons.Count > 0;
               if (overlayObject && !all)
                  break;
            }

            if (!overlayObject && core.MouseDown != GPoint.Empty)
               point = MapFromLocalToLatLng(e.X, e.Y);
         }

         return point;
      }

#if !GMAP4SKIA
      protected override void OnMouseDoubleClick(MouseEventArgs e) {
         base.OnMouseDoubleClick(e);
         _onMouseClick(e, true, false, out _, out _, out _);
      }
#else
      PointLatLng OnMouseDoubleClick(MouseEventArgs e,
                                     bool all,
                                     out List<GMapMarker> markers,
                                     out List<GMapTrack> tracks,
                                     out List<GMapPolygon> polygons) {
         MouseDoubleClick?.Invoke(this, e);
         return _onMouseClick(e,
                              true,
                              all,
                              out markers,
                              out tracks,
                              out polygons);
      }
#endif

#if !GMAP4SKIA
      protected override void OnMouseMove(MouseEventArgs e) {
         base.OnMouseMove(e);
#else
      /// <summary>
      /// zur Simulation einer Mausbewegung (auch mit ModifierKeys == Keys.Alt für Selektion!)
      /// </summary>
      /// <param name="e"></param>
      protected virtual void OnMouseMove(MouseEventArgs e) {
         MouseMove?.Invoke(this, e);
#endif
         if (!core.IsDragging &&             // noch nicht gestartet ...
             !core.MouseDown.IsEmpty) {      // ... und Startpunkt bei MouseDown registriert ...
            var p = applyRotationInversion(e.X, e.Y);
            if (Math.Abs(p.X - core.MouseDown.X) * 2 >= dragSize.Width ||  // ... und Mindestweite der Bewegung vorhanden
                Math.Abs(p.Y - core.MouseDown.Y) * 2 >= dragSize.Height)
               core.BeginDrag(core.MouseDown);  // Dragging mit diesen Clientkoordinaten starten
         }

         if (core.IsDragging) {
            if (!_isDragging) {
               _isDragging = true;
#if !GMAP4SKIA
               cursorBefore = Cursor;
               Cursor = Cursors.SizeAll;
#endif
            }

            if (boundsOfMap.HasValue && !boundsOfMap.Value.Contains(MapPosition)) {
               // ...
            } else {
               GPoint pt = applyRotationInversion(e.X, e.Y);
               core.Drag(pt);

               //if (MobileMode || IsRotated)
               //{
               //    ForceUpdateOverlays();
               //}
               ForceUpdateOverlays();
               ControlInvalidate();
            }
         } else {
            if (isSelected &&
                !selectionStart.IsEmpty &&
                (ModifierKeys == Keys.Alt || ModifierKeys == Keys.Shift || MapDisableAltForSelection)) {
               selectionEnd = MapFromLocalToLatLng(e.X, e.Y);
               {
                  var p1 = selectionStart;
                  var p2 = selectionEnd;

                  double x1 = Math.Min(p1.Lng, p2.Lng);
                  double y1 = Math.Max(p1.Lat, p2.Lat);
                  double x2 = Math.Max(p1.Lng, p2.Lng);
                  double y2 = Math.Min(p1.Lat, p2.Lat);

                  MapSelectedArea = new RectLatLng(y1, x1, x2 - x1, y1 - y2);
               }
            } else
            if (core.MouseDown.IsEmpty) {
               for (int i = MapOverlays.Count - 1; i >= 0; i--) {
                  var o = MapOverlays[i];

                  var rp = !mobileMode ? core.FromClientToGlobal(e.X, e.Y) : new GPoint(e.X, e.Y);

                  if (o != null && o.IsVisibile && o.IsHitTestVisible) {

                     List<GMapMarker> markers = getMarkers4Point(o, rp, true);
                     List<GMapTrack> tracks = getTracks4Point(o, rp, true, MapClickTolerance4Tracks);
                     List<GMapPolygon> polygons = getPolygons4Point(o, e.X, e.Y, true);


                     foreach (var m in o.Markers) {
                        if (m.IsVisible &&
                            m.IsHitTestVisible) {
                           if (markers.Contains(m)) {
                              if (!m.IsMouseOver) {
                                 setCursorHandOnEnter();
                                 m.IsMouseOver = true;
                                 MapIsMouseOverMarker = true;
                                 OnMapMarkerEnter?.Invoke(this, new GMapMarkerEventArgs(m, null));
                                 MapCoreInvalidate();
                              }
                           } else if (m.IsMouseOver) {
                              m.IsMouseOver = false;
                              MapIsMouseOverMarker = false;
                              RestoreCursorOnLeave();
                              OnMapMarkerLeave?.Invoke(this, new GMapMarkerEventArgs(m, null));
                              MapCoreInvalidate();
                           }
                        }
                     }

                     foreach (var t in o.Tracks) {
                        if (t.IsVisible &&
                            t.IsHitTestVisible) {
                           if (tracks.Contains(t)) {
                              if (!t.IsMouseOver) {
                                 setCursorHandOnEnter();
                                 t.IsMouseOver = true;
                                 MapIsMouseOverTrack = true;
                                 OnMapTrackEnter?.Invoke(this, new GMapTrackEventArgs(t, null));
                                 MapCoreInvalidate();
                              }
                           } else if (t.IsMouseOver) {
                              t.IsMouseOver = false;
                              MapIsMouseOverTrack = false;
                              RestoreCursorOnLeave();
                              OnMapTrackLeave?.Invoke(this, new GMapTrackEventArgs(t, null));
                              MapCoreInvalidate();
                           }
                        }
                     }

                     foreach (var p in o.Polygons) {
                        if (p.IsVisible &&
                            p.IsHitTestVisible) {
                           if (polygons.Contains(p)) {
                              if (!p.IsMouseOver) {
                                 setCursorHandOnEnter();
                                 p.IsMouseOver = true;
                                 MapIsMouseOverPolygon = true;
                                 OnMapPolygonEnter?.Invoke(this, new GMapPolygonEventArgs(p, null));
                                 MapCoreInvalidate();
                              }
                           } else if (p.IsMouseOver) {
                              p.IsMouseOver = false;
                              MapIsMouseOverPolygon = false;
                              RestoreCursorOnLeave();
                              OnMapPolygonLeave?.Invoke(this, new GMapPolygonEventArgs(p, null));
                              MapCoreInvalidate();
                           }
                        }
                     }
                  }
               }
            }
         }
      }


#if !GMAP4SKIA
      protected override void OnPaint(PaintEventArgs e) {
#else
      protected virtual void OnPaint(PaintEventArgs e) {
#endif
         try {
            if (mapForceDoubleBuffer &&
                graphicsBackBuffer != null) {
               drawGraphics(graphicsBackBuffer);
               e.Graphics.DrawImage(_backBuffer, 0, 0);
            } else
               drawGraphics(e.Graphics);
#if !GMAP4SKIA
            base.OnPaint(e);
#endif
         } catch (Exception ex) {
            if (OnMapExceptionThrown != null)
               OnMapExceptionThrown.Invoke(new Exception("OnPaint", ex));
            else
               throw;
         }
#if GMAP4SKIA
         Paint?.Invoke(this, e);
#endif
      }

#if !GMAP4SKIA
      protected override void OnSizeChanged(EventArgs e) {
         base.OnSizeChanged(e);
#else
      protected virtual void OnSizeChanged(EventArgs e) {
         MainThread.InvokeOnMainThreadAsync(() => {
            Width = (int)Math.Round(XamarinX2SkiaX(base.Width));
            Height = (int)Math.Round(XamarinY2SkiaY(base.Height));
         }).Wait();
#endif
         if (Width == 0 || Height == 0)
            return;

         if (Width == core.Width && Height == core.Height)
            return;

         if (!IsDesignerHosted) {
            if (mapForceDoubleBuffer)
               UpdateBackBuffer();

            if (mapVirtualSizeEnabled)
               core.OnMapSizeChanged(core.VWidth, core.VHeight);
            else
               core.OnMapSizeChanged(Width, Height);

            if (Visible &&
                IsHandleCreated &&
                core.IsStarted) {
               if (MapIsRotated)
                  updateRotationMatrix();

               ForceUpdateOverlays();
            }
         }
      }

#if !GMAP4SKIA
      protected override void OnLoad(EventArgs e) {
#else
      protected virtual void OnLoad(EventArgs e) {
#endif
         try {
#if !GMAP4SKIA
            base.OnLoad(e);
#else
            core.SystemType = "SkiaAndroid";

            // Skia-Event auf OnSizeChanged umlenken
            SizeChanged += (object sender, EventArgs ea) => {
               OnSizeChanged(ea);
            };

            // Skia-Event auf OnPaint umlenken
            PaintSurface += (object sender, SKPaintSurfaceEventArgs ea) => {
               Graphics g = new Graphics(ea.Surface.Canvas);
               OnPaint(new PaintEventArgs(g, new Rectangle(0, 0, ea.Info.Width, ea.Info.Height)));
               g.Dispose();
            };
#endif
            if (!IsDesignerHosted) {
               //MethodInvoker m = delegate
               //{
               //   Thread.Sleep(444);

               //OnSizeChanged(null);

               if (_lazyEvents) {
                  _lazyEvents = false;

                  if (_lazySetZoomToFitRect.HasValue) {
                     MapSetZoomToFitRect(_lazySetZoomToFitRect.Value);
                     _lazySetZoomToFitRect = null;
                  }
               }

               core.OnMapOpen().ProgressChanged += invalidatorEngage;
               ForceUpdateOverlays();
               //};
               //this.BeginInvoke(m);
            }
         } catch (Exception ex) {
            if (OnMapExceptionThrown != null)
               OnMapExceptionThrown.Invoke(new Exception("OnLoad", ex));
            else
               throw;
         }
      }

      /// <summary>
      /// override, to render something more
      /// </summary>
      /// <param name="g"></param>
      protected virtual void OnPaintOverlays(Graphics g) {
         try {
            g.SmoothingMode = SmoothingMode.HighQuality;
            foreach (var o in MapOverlays)
               if (o.IsVisibile)
                  o.OnRender(g);

            // separate tooltip drawing
            foreach (var o in MapOverlays)
               if (o.IsVisibile)
                  o.OnRenderToolTips(g);

            if (!mobileMode)
               g.ResetTransform();

            if (!MapSelectedArea.IsEmpty) {
               var p1 = MapFromLatLngToLocal(MapSelectedArea.LocationTopLeft);
               var p2 = MapFromLatLngToLocal(MapSelectedArea.LocationRightBottom);

               long x1 = p1.X;
               long y1 = p1.Y;
               long x2 = p2.X;
               long y2 = p2.Y;

               g.DrawRectangle(MapSelectionPen, x1, y1, x2 - x1, y2 - y1);
               g.FillRectangle(_selectedAreaFillBrush, x1, y1, x2 - x1, y2 - y1);
            }

            #region -- copyright --

            if (!string.IsNullOrEmpty(core.Provider.Copyright)) {
#if GMAP4SKIA
               g.DrawString(core.Provider.Copyright,
                            MapCopyrightFont,
                            Brushes.Navy as SolidBrush,
                            new PointF(15, Height - MapCopyrightFont.GetHeight() - 25));
#else
               g.DrawString(core.Provider.Copyright,
                            MapCopyrightFont,
                            Brushes.Navy,
                            3,
                            Height - MapCopyrightFont.Height - 5);
#endif
            }

            #endregion

            OnMapDrawCenter(new DrawExtendedEventArgs(g, MapRenderTransform));

            OnMapDrawScale(new DrawExtendedEventArgs(g, MapRenderTransform));

            OnMapDrawOnTop(new DrawExtendedEventArgs(g, MapRenderTransform));

         } catch (Exception ex) {
            if (OnMapExceptionThrown != null)
               OnMapExceptionThrown.Invoke(new Exception("OnPaintOverlays", ex));
            else
               throw new Exception("OnPaintOverlays: " + ex.Message);
         }
      }

      protected virtual void OnMapDrawCenter(DrawExtendedEventArgs e) {
         int r = Math.Min(Width, Height) / 50;
         e.Graphics.DrawLine(mapCenterPen,
                             Width / 2 - r,
                             Height / 2,
                             Width / 2 + r,
                             Height / 2);
         e.Graphics.DrawLine(mapCenterPen,
                             Width / 2,
                             Height / 2 - r,
                             Width / 2,
                             Height / 2 + r);
      }

      protected virtual void OnMapDrawScale(DrawExtendedEventArgs e) {
         //         int top = MapScaleInfoPosition == MapScaleInfoPositions.Top ?
         //                           10 :
         //#if !GMAP4SKIA
         //                           Bottom
         //#else
         //                                 Height
         //#endif
         //                           - 30;
         //         int left = 10;
         //         int bottom = top + 7;

         //         if (Width > Core.PxRes5000Km)
         //            drawSimpleScale(e.Graphics, top, left + Core.PxRes5000Km, bottom, left, "5000 km");

         //         if (Width > Core.PxRes1000Km)
         //            drawSimpleScale(e.Graphics, top, left + Core.PxRes1000Km, bottom, left, "1000 km");

         //         if (Width > Core.PxRes100Km && MapZoom > 2)
         //            drawSimpleScale(e.Graphics, top, left + Core.PxRes100Km, bottom, left, "100 km");

         //         if (Width > Core.PxRes10Km && MapZoom > 5)
         //            drawSimpleScale(e.Graphics, top, left + Core.PxRes10Km, bottom, left, "10 km");

         //         if (Width > Core.PxRes1000M && MapZoom >= 10)
         //            drawSimpleScale(e.Graphics, top, left + Core.PxRes1000M, bottom, left, "1000 m");

         //         if (Width > Core.PxRes100M && MapZoom > 11)
         //            drawSimpleScale(e.Graphics, top, left + Core.PxRes100M, bottom, left, "100 m");
      }

      protected virtual void OnMapDrawOnTop(DrawExtendedEventArgs e) { }

      #region Event-Funktionen nur für Standard-Windows-Control-Events

#if !GMAP4SKIA
      protected override void OnCreateControl() {
         try {
            base.OnCreateControl();

            if (!IsDesignerHosted) {
               var f = ParentForm;
               if (f != null) {
                  while (f.ParentForm != null)
                     f = f.ParentForm;

                  if (f != null)
                     f.FormClosing += ParentForm_FormClosing;
               }
            }
         } catch (Exception ex) {
            if (OnMapExceptionThrown != null)
               OnMapExceptionThrown.Invoke(ex);
            else
               throw;
         }
      }

      void ParentForm_FormClosing(object sender, FormClosingEventArgs e) {
         //if (e.CloseReason == CloseReason.WindowsShutDown ||
         //    e.CloseReason == CloseReason.TaskManagerClosing)
         MapManager.CancelTileCaching();
         core.Dispose();
      }

      protected override void OnKeyDown(KeyEventArgs e) {
         base.OnKeyDown(e);
      }

      protected override void OnKeyUp(KeyEventArgs e) {
         base.OnKeyUp(e);
      }

      bool _mouseIn;

      protected override void OnMouseEnter(EventArgs e) {
         base.OnMouseEnter(e);

         if (!mapDisableFocusOnMouseEnter)
            Focus();

         _mouseIn = true;
      }

      protected override void OnMouseLeave(EventArgs e) {
         base.OnMouseLeave(e);
         _mouseIn = false;
      }

      public bool MouseWheelZoomEnabled = true;

      protected override void OnMouseWheel(MouseEventArgs e) {
         base.OnMouseWheel(e);

         if (MouseWheelZoomEnabled &&
             _mouseIn &&
             (!MapIsMouseOverMarker || mapIgnoreMarkerOnMouseWheel) &&
             !core.IsDragging) {
            if (core.MouseLastZoom.X != e.X && core.MouseLastZoom.Y != e.Y) {
               switch (MouseWheelZoomType) {
                  case MouseWheelZoomType.MousePositionAndCenter:
                  case MouseWheelZoomType.MousePositionWithoutCenter:
                     core.SetPositionDirect(MapFromLocalToLatLng(e.X, e.Y));
                     break;
                  case MouseWheelZoomType.ViewCenter:
                     core.SetPositionDirect(MapFromLocalToLatLng(Width / 2, Height / 2));
                     break;
               }
               core.MouseLastZoom = new GPoint(e.X, e.Y);
            }

            // set mouse position to map center
            if (MouseWheelZoomType != MouseWheelZoomType.MousePositionWithoutCenter) {
               if (!GMaps.Instance.IsRunningOnMono) {
                  var p = PointToScreen(new Point(Width / 2, Height / 2));
                  PublicCore.SetMousePosition(p.X, p.Y);
               }
            }

            core.MouseWheelZooming = true;

            if (e.Delta > 0) {
               if (!mapInvertedMouseWheelZooming)
                  MapZoom = (int)MapZoom + 1;
               else
                  MapZoom = (int)(MapZoom + 0.99) - 1;
            } else if (e.Delta < 0) {
               if (!mapInvertedMouseWheelZooming)
                  MapZoom = (int)(MapZoom + 0.99) - 1;
               else
                  MapZoom = (int)MapZoom + 1;
            }

            core.MouseWheelZooming = false;
         }
      }

#endif

      #endregion

      #endregion

      #region Public-Funktionen

      /// <summary>
      ///     Call it to empty tile cache & reload tiles
      /// </summary>
      public void MapReload() => core.ReloadMap();

      /// <summary>
      ///     gets world coordinate from local control coordinate
      /// </summary>
      /// <param name="x"></param>
      /// <param name="y"></param>
      /// <returns></returns>
      public PointLatLng MapFromLocalToLatLng(int x, int y) {
         core.FromScaledLocalToLocal(ref x, ref y, getScale());
         applyRotationInversion(ref x, ref y);
         core.ApplyVirtualSizeForLocal(ref x, ref y);
         return core.FromLocalToLatLng(x, y);
      }

      /// <summary>
      ///     gets local coordinate from world coordinate
      /// </summary>
      /// <param name="point"></param>
      /// <returns></returns>
      public GPoint MapFromLatLngToLocal(PointLatLng point) {
         var ptClient = core.FromLatLngToLocal(point, getScale());
         applyRotation(ptClient);
         core.ApplyVirtualSizeForLocal(ref ptClient);
         return ptClient;
      }

#if !GMAP4SKIA && WITHORGCODE

      /// <summary>
      ///     shows map db export dialog
      /// </summary>
      /// <returns></returns>
      public bool MapShowExportDialog() {
         using (FileDialog dlg = new SaveFileDialog()) {
            dlg.CheckPathExists = true;
            dlg.CheckFileExists = false;
            dlg.AddExtension = true;
            dlg.DefaultExt = "gmdb";
            dlg.ValidateNames = true;
            dlg.Title = "GMap.NET: Export map to db, if file exsist only new data will be added";
            dlg.FileName = "DataExp";
            dlg.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
            dlg.Filter = "GMap.NET DB files (*.gmdb)|*.gmdb";
            dlg.FilterIndex = 1;
            dlg.RestoreDirectory = true;

            if (dlg.ShowDialog() == DialogResult.OK) {
               bool ok = GMaps.Instance.ExportToGMDB(dlg.FileName);
               if (ok) {
                  MessageBox.Show("Complete!", "GMap.NET", MessageBoxButtons.OK, MessageBoxIcon.Information);
               } else {
                  MessageBox.Show("Failed!", "GMap.NET", MessageBoxButtons.OK, MessageBoxIcon.Warning);
               }

               return ok;
            }
         }

         return false;
      }

      /// <summary>
      ///     shows map dbimport dialog
      /// </summary>
      /// <returns></returns>
      public bool MapShowImportDialog() {
         using (FileDialog dlg = new OpenFileDialog()) {
            dlg.CheckPathExists = true;
            dlg.CheckFileExists = false;
            dlg.AddExtension = true;
            dlg.DefaultExt = "gmdb";
            dlg.ValidateNames = true;
            dlg.Title = "GMap.NET: Import to db, only new data will be added";
            dlg.FileName = "DataImport";
            dlg.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
            dlg.Filter = "GMap.NET DB files (*.gmdb)|*.gmdb";
            dlg.FilterIndex = 1;
            dlg.RestoreDirectory = true;

            if (dlg.ShowDialog() == DialogResult.OK) {
               bool ok = GMaps.Instance.ImportFromGMDB(dlg.FileName);
               if (ok) {
                  MessageBox.Show("Complete!", "GMap.NET", MessageBoxButtons.OK, MessageBoxIcon.Information);
                  MapReload();
               } else {
                  MessageBox.Show("Failed!", "GMap.NET", MessageBoxButtons.OK, MessageBoxIcon.Warning);
               }

               return ok;
            }
         }

         return false;
      }

#endif

      /// <summary>
      ///     call this to stop HoldInvalidation and perform single forced instant refresh
      /// </summary>
      public void MapRefresh() {
         HoldInvalidation = false;
         lock (core.InvalidationLock) {
            core.LastInvalidation = DateTime.Now;
         }

#if GMAP4SKIA
         InvalidateSurface();
#else
         base.Refresh();
#endif
      }

      RectLatLng? _lazySetZoomToFitRect;
      bool _lazyEvents = true;

      /// <summary>
      /// sets zoom to max to fit rect
      /// </summary>
      /// <param name="rect"></param>
      /// <returns></returns>
      public bool MapSetZoomToFitRect(RectLatLng rect) {
         if (_lazyEvents) {
            _lazySetZoomToFitRect = rect;
         } else {
            int maxZoom = core.GetMaxZoomToFitRect(rect);
            if (maxZoom > 0) {
               var center = new PointLatLng(rect.Lat - rect.HeightLat / 2, rect.Lng + rect.WidthLng / 2);
               MapPosition = center;
               if (maxZoom > MapMaxZoom)
                  maxZoom = MapMaxZoom;
               if ((int)MapZoom != maxZoom)
                  MapZoom = maxZoom;
               return true;
            }
         }
         return false;
      }

#if WITHORGCODE

      /// <summary>
      ///     sets to max zoom to fit all markers and centers them in map
      /// </summary>
      /// <param name="overlayId">overlay id or null to check all</param>
      /// <returns></returns>
      public bool MapZoomAndCenterMarkers(string overlayId) {
         return MapZoomAndCenterRect(GetRectOfAllMarkers(overlayId));
      }

      /// <summary>
      ///     zooms and centers all tracks
      /// </summary>
      /// <param name="overlayId">overlay id or null to check all</param>
      /// <returns></returns>
      public bool MapZoomAndCenterTracks(string overlayId) {
         return MapZoomAndCenterRect(GetRectOfAllTracks(overlayId));
      }

      /// <summary>
      ///     zooms and centers tracks
      /// </summary>
      /// <param name="track"></param>
      /// <returns></returns>
      public bool MapZoomAndCenterTrack(MapRoute track) {
         return MapZoomAndCenterRect(GetRectOfTrack(track));
      }

      public bool MapZoomAndCenterRect(RectLatLng? rect) {
         return rect.HasValue ?
                        MapSetZoomToFitRect(rect.Value) :
                        false;
      }

#endif

#if GMAP4SKIA
      /// <summary>
      /// gets image of the current view
      /// </summary>
      /// <returns></returns>
      public Bitmap MapToImage() {
         Bitmap ret = null;
         bool r = mapForceDoubleBuffer;
         try {
            UpdateBackBuffer();
            if (!r)
               mapForceDoubleBuffer = true;
            MapRefresh();
            //Application.DoEvents();

            using (var ms = new MemoryStream()) {
               using (var frame = _backBuffer.Clone() as Bitmap) {
                  frame.Save(ms, ImageFormat.Png);
               }
               ret = Bitmap.FromStream(ms);
            }
         } catch (Exception) {
            throw;
         } finally {
            if (!r) {
               mapForceDoubleBuffer = false;
               ClearBackBuffer();
            }
         }
         return ret;
      }
#else
      /// <summary>
      /// gets image of the current view
      /// </summary>
      /// <returns></returns>
      public Image MapToImage() {
         Image ret = null;
         bool r = mapForceDoubleBuffer;
         try {
            UpdateBackBuffer();
            if (!r)
               mapForceDoubleBuffer = true;
            MapRefresh();
            Application.DoEvents();

            using (var ms = new MemoryStream()) {
               using (var frame = _backBuffer.Clone() as Bitmap)
                  frame.Save(ms, ImageFormat.Png);
               ret = Image.FromStream(ms);
            }
         } catch (Exception) {
            throw;
         } finally {
            if (!r) {
               mapForceDoubleBuffer = false;
               ClearBackBuffer();
            }
         }
         return ret;
      }
#endif

      ///// <summary>
      /////     offset position in pixels
      ///// </summary>
      ///// <param name="x"></param>
      ///// <param name="y"></param>
      //public void Offset(int x, int y) {
      //   if (IsHandleCreated) {
      //      if (MapIsRotated) {
      //         var p = new[] { new Point(x, y) };
      //         rotationMatrixInvert.TransformVectors(p);
      //         x = p[0].X;
      //         y = p[0].Y;
      //      }
      //      core.DragOffset(new GPoint(x, y));
      //      ForceUpdateOverlays();
      //   }
      //}

      ///// <summary>
      /////     Obtains the orientation between two points expressed in degrees
      ///// </summary>
      ///// <param name="startPoint"></param>
      ///// <param name="endPoint"></param>
      ///// <returns></returns>
      //public double GetBearing(PointLatLng startPoint, PointLatLng endPoint) {
      //   //double startLat, double startLong, double endLat, double endLong
      //   double startLat = radians(startPoint.Lat);
      //   double startLong = radians(startPoint.Lng);
      //   double endLat = radians(endPoint.Lat);
      //   double endLong = radians(endPoint.Lng);

      //   double dLong = endLong - startLong;

      //   double dPhi = Math.Log(Math.Tan(endLat / 2.0 + Math.PI / 4.0) / Math.Tan(startLat / 2.0 + Math.PI / 4.0));
      //   if (Math.Abs(dLong) > Math.PI) {
      //      if (dLong > 0.0)
      //         dLong = -(2.0 * Math.PI - dLong);
      //      else
      //         dLong = 2.0 * Math.PI + dLong;
      //   }

      //   return Math.Round((degrees(Math.Atan2(dLong, dPhi)) + 360.0) % 360.0, 2);
      //}

      ///// <summary>
      /////     check if a given point is within the given point based map boundary
      ///// </summary>
      ///// <param name="points"></param>
      ///// <param name="lat"></param>
      ///// <param name="lng"></param>
      ///// <returns></returns>
      //public bool IsPointInBoundary(List<PointLatLng> points, string lat, string lng) {
      //   var polyOverlay = new GMapOverlay();
      //   var polygon = new GMapPolygon(points, "routePloygon");
      //   polygon.Fill = new SolidBrush(Color.FromArgb(50, Color.Red));
      //   polygon.Stroke = new Pen(Color.Red, 1);
      //   polyOverlay.Polygons.Add(polygon);
      //   var pnt = new PointLatLng(double.Parse(lat), double.Parse(lng));
      //   return polygon.IsInside(pnt);
      //}

      ///// <summary>
      /////     set current position using keywords
      ///// </summary>
      ///// <param name="keys"></param>
      ///// <returns>true if successfull</returns>
      //public GeoCoderStatusCode MapSetPositionByKeywords(string keys) {
      //   var status = GeoCoderStatusCode.UNKNOWN_ERROR;
      //   var gp = MapProvider as GeocodingProvider;

      //   if (gp == null)
      //      gp = GMapProviders.OpenStreetMap as GeocodingProvider;

      //   if (gp != null) {
      //      var pt = gp.GetPoint(keys.Replace("#", "%23"), out status);

      //      if (status == GeoCoderStatusCode.OK && pt.HasValue)
      //         MapPosition = pt.Value;
      //   }

      //   return status;
      //}

      ///// <summary>
      /////     get current position using keywords
      ///// </summary>
      ///// <param name="keys"></param>
      ///// <param name="point"></param>
      ///// <returns></returns>
      //public GeoCoderStatusCode MapGetPositionByKeywords(string keys, out PointLatLng point) {
      //   point = new PointLatLng();

      //   var status = GeoCoderStatusCode.UNKNOWN_ERROR;
      //   var gp = MapProvider as GeocodingProvider;

      //   if (gp == null)
      //      gp = GMapProviders.OpenStreetMap as GeocodingProvider;

      //   if (gp != null) {
      //      var pt = gp.GetPoint(keys.Replace("#", "%23"), out status);

      //      if (status == GeoCoderStatusCode.OK && pt.HasValue)
      //         point = pt.Value;
      //   }

      //   return status;
      //}

      /// <summary>
      /// ermittelt das jeweils erste Objekt der Objektarten Marker, Track und Polygon, dass an diesem Punkt liegt
      /// und löst die zugehörigen Events aus (z.Z. nur für Skia !!!)
      /// <para>Gibt es kein Objekt, wird die geohrafische Position geliefert.</para>
      /// </summary>
      /// <param name="clientx"></param>
      /// <param name="clienty"></param>
      /// <param name="doubleclick">Klick oder Doppelklick</param>
      /// <param name="button">Mausbutton</param>
      /// <param name="all">bei true werden alle Objekte ermittelt</param>
      /// <param name="marker">Liste der Marker</param>
      /// <param name="track">Liste der Tracks</param>
      /// <param name="polygon">Liste der Polygone</param>
      /// <returns></returns>
      public PointLatLng MapTapped(int clientx,
                                   int clienty,
                                   bool doubleclick,
                                   MouseButtons button,
                                   bool all,
                                   out List<GMapMarker> marker,
                                   out List<GMapTrack> track,
                                   out List<GMapPolygon> polygon) {
#if GMAP4SKIA
         simulateMousePosition(clientx, clienty);
         return doubleclick ?
                     OnMouseDoubleClick(new MouseEventArgs(button, clientx, clienty, 0),
                                        all,
                                        out marker,
                                        out track,
                                        out polygon) :

                     OnMouseClick(new MouseEventArgs(button, clientx, clienty, 0),
                                  all,
                                  out marker,
                                  out track,
                                  out polygon);
#else

         // DUMMY

         marker = new List<GMapMarker>();
         track = new List<GMapTrack>();
         polygon = new List<GMapPolygon>();
         return new PointLatLng(0, 0);
#endif
      }

      #endregion

      #region Protected-Funktionen

      /// <summary>
      ///     update objects when map is draged/zoomed
      /// </summary>
      protected void ForceUpdateOverlays() {
         try {
            HoldInvalidation = true;
            foreach (var o in MapOverlays) {
               if (o.IsVisibile)
                  o.ForceUpdate();
            }
         } finally {
            MapRefresh();
         }
      }

#if WITHORGCODE

      /// <summary>
      ///     gets rectangle with all objects inside
      /// </summary>
      /// <param name="overlayId">overlay id or null to check all except zoomInsignificant</param>
      /// <returns></returns>
      protected RectLatLng? GetRectOfAllMarkers(string overlayId) {
         RectLatLng? ret = null;

         double left = double.MaxValue;
         double top = double.MinValue;
         double right = double.MinValue;
         double bottom = double.MaxValue;

         foreach (var o in MapOverlays) {
            if (overlayId == null && o.IsZoomSignificant || o.Id == overlayId) {
               if (o.IsVisibile && o.Markers.Count > 0) {
                  foreach (var m in o.Markers) {
                     if (m.IsVisible) {
                        // left
                        if (m.Position.Lng < left)
                           left = m.Position.Lng;
                        // top
                        if (m.Position.Lat > top)
                           top = m.Position.Lat;
                        // right
                        if (m.Position.Lng > right)
                           right = m.Position.Lng;
                        // bottom
                        if (m.Position.Lat < bottom)
                           bottom = m.Position.Lat;
                     }
                  }
               }
            }
         }

         if (left != double.MaxValue &&
             right != double.MinValue &&
             top != double.MinValue &&
             bottom != double.MaxValue)
            ret = RectLatLng.FromLTRB(left, top, right, bottom);
         return ret;
      }

      /// <summary>
      ///     gets rectangle with all objects inside
      /// </summary>
      /// <param name="overlayId">overlay id or null to check all except zoomInsignificant</param>
      /// <returns></returns>
      protected RectLatLng? GetRectOfAllTracks(string overlayId) {
         RectLatLng? ret = null;

         double left = double.MaxValue;
         double top = double.MinValue;
         double right = double.MinValue;
         double bottom = double.MaxValue;

         foreach (var o in MapOverlays) {
            if (overlayId == null && o.IsZoomSignificant || o.Id == overlayId) {
               if (o.IsVisibile && o.Tracks.Count > 0) {
                  foreach (var t in o.Tracks) {
                     if (t.IsVisible && t.From.HasValue && t.To.HasValue) {
                        foreach (var p in t.Points) {
                           // left
                           if (p.Lng < left)
                              left = p.Lng;
                           // top
                           if (p.Lat > top)
                              top = p.Lat;
                           // right
                           if (p.Lng > right)
                              right = p.Lng;
                           // bottom
                           if (p.Lat < bottom)
                              bottom = p.Lat;
                        }
                     }
                  }
               }
            }
         }

         if (left != double.MaxValue &&
             right != double.MinValue &&
             top != double.MinValue &&
             bottom != double.MaxValue)
            ret = RectLatLng.FromLTRB(left, top, right, bottom);
         return ret;
      }

      /// <summary>
      ///     gets rect of track
      /// </summary>
      /// <param name="track"></param>
      /// <returns></returns>
      protected RectLatLng? GetRectOfTrack(MapRoute track) {
         RectLatLng? ret = null;

         double left = double.MaxValue;
         double top = double.MinValue;
         double right = double.MinValue;
         double bottom = double.MaxValue;

         if (track.From.HasValue && track.To.HasValue) {
            foreach (var p in track.Points) {
               // left
               if (p.Lng < left)
                  left = p.Lng;
               // top
               if (p.Lat > top)
                  top = p.Lat;
               // right
               if (p.Lng > right)
                  right = p.Lng;
               // bottom
               if (p.Lat < bottom)
                  bottom = p.Lat;
            }
            ret = RectLatLng.FromLTRB(left, top, right, bottom);
         }
         return ret;
      }

#endif

      protected List<GMapMarker> getMarkers4Point(GMapOverlay o, GPoint clientwithoffset, bool all = true) {
         List<GMapMarker> markers = new List<GMapMarker>();
         foreach (var m in o.Markers) {
            if (m.IsVisible && m.IsHitTestVisible) {
               if (m.LocalArea.Contains((int)clientwithoffset.X, (int)clientwithoffset.Y)) {
                  markers.Add(m);
                  if (!all)
                     break;
               }
            }
         }
         return markers;
      }

      protected List<GMapTrack> getTracks4Point(GMapOverlay o, GPoint clientwithoffset, bool all = true, float tolerance = 1F) {
         List<GMapTrack> tracks = new List<GMapTrack>();
         foreach (var t in o.Tracks) {
            if (t.IsVisible && t.IsHitTestVisible) {
               if (t.IsInside((int)clientwithoffset.X, (int)clientwithoffset.Y, tolerance)) {
                  tracks.Add(t);
                  if (!all)
                     break;
               }
            }
         }
         return tracks;
      }

      protected List<GMapPolygon> getPolygons4Point(GMapOverlay o, int clientx, int clienty, bool all = true) {
         List<GMapPolygon> polys = new List<GMapPolygon>();
         foreach (var p in o.Polygons) {
            if (p.IsVisible && p.IsHitTestVisible) {
               if (p.IsInside(MapFromLocalToLatLng(clientx, clienty))) {
                  polys.Add(p);
                  if (!all)
                     break;
               }
            }
         }
         return polys;
      }

      #endregion

      #region Privat-Funktionen

      #region Backbuffer

      Bitmap _backBuffer;

      void UpdateBackBuffer() {
         ClearBackBuffer();

         _backBuffer = new Bitmap(Width, Height);
         graphicsBackBuffer = Graphics.FromImage(_backBuffer);
      }

      void ClearBackBuffer() {
         if (_backBuffer != null) {
            _backBuffer.Dispose();
            _backBuffer = null;
         }

         if (graphicsBackBuffer != null) {
            graphicsBackBuffer.Dispose();
            graphicsBackBuffer = null;
         }
      }

      #endregion

      static double radians(double degrees) => degrees * (Math.PI / 180);

      static double degrees(double radians) => radians * (180 / Math.PI);

      float getScale() {
         //return (_mapRenderTransform ?? 1) * (_mapRenderZoom2RealDevice ?? 1);
         return MapRenderTransform * MapRenderZoom2RealDevice;
      }

      void overlays_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e) {
         if (e.NewItems != null) {
            foreach (GMapOverlay obj in e.NewItems)
               if (obj != null)
                  obj.Control = this;

            if (core.IsStarted &&
                !HoldInvalidation)
               MapCoreInvalidate();
         }
      }

      void invalidatorEngage(object sender, ProgressChangedEventArgs e) {
         ControlInvalidate();
      }

      void ControlInvalidate() {
#if !GMAP4SKIA
         base.Invalidate();
#else
         MainThread.BeginInvokeOnMainThread(() => InvalidateSurface());
         //InvalidateSurface();
#endif
      }

      /// <summary>
      /// draw the map and the overlays to graphics
      /// </summary>
      /// <param name="g"></param>
      void drawGraphics(Graphics g) {
         g.Clear(MapEmptyMapBackgroundColor);
         g.TextRenderingHint = TextRenderingHint.AntiAlias;
         g.SmoothingMode = SmoothingMode.AntiAlias;

         float scale = getScale();
         if (scale != 1) {
            if (!mobileMode) {
               //var delta = new GPoint(Width / 2, Height / 2);
               //var pos = delta;
               //delta.OffsetNegative(core.RenderOffset);
               //pos.OffsetNegative(delta);

               //g.ScaleTransform(scale, scale, MatrixOrder.Append);
               //g.TranslateTransform(pos.X, pos.Y, MatrixOrder.Append);

               //drawMap(g);

               //g.ResetTransform();
               //g.TranslateTransform(pos.X, pos.Y, MatrixOrder.Append);


               g.ScaleTransform(scale, scale, MatrixOrder.Append);
               g.TranslateTransform(CoreRenderOffsetX, CoreRenderOffsetY, MatrixOrder.Append);
               drawMap(g);
               g.ResetTransform();
               g.TranslateTransform(CoreRenderOffsetX, CoreRenderOffsetY, MatrixOrder.Append);

            } else {
               drawMap(g);
               g.ResetTransform();
            }
            OnPaintOverlays(g);

         } else {
            if (MapIsRotated) {
               g.TranslateTransform((float)(Width / 2.0), (float)(Height / 2.0));
               g.RotateTransform(-MapBearing);
               g.TranslateTransform((float)(Width / 2.0), (float)(Height / 2.0));

               g.TranslateTransform(CoreRenderOffsetX, CoreRenderOffsetY);

               drawMap(g);

               g.ResetTransform();
               g.TranslateTransform(CoreRenderOffsetX, CoreRenderOffsetY);

               OnPaintOverlays(g);
            } else {
               if (!mobileMode)
                  g.TranslateTransform(CoreRenderOffsetX, CoreRenderOffsetY);
               drawMap(g);
               OnPaintOverlays(g);
            }
         }

         if (mapForTestShowCoreData)
            showCoreData(g);
      }

      void drawMap(Graphics g) {
         if (core.UpdatingBounds ||
             MapProvider == EmptyProvider.Instance ||
             MapProvider == null)
            return;

         core.TileDrawingListLock.AcquireReaderLock();
         core.Matrix_EnterReadLock();

         //g.TextRenderingHint = TextRenderingHint.AntiAlias;
         //g.SmoothingMode = SmoothingMode.AntiAlias;
         //g.CompositingQuality = CompositingQuality.HighQuality;
         //g.InterpolationMode = InterpolationMode.HighQualityBicubic;  

         try {
            GPoint[] _tilePointPosXY = core.GetTileDrawingList(out GPoint[] _tilePointPosPixel);
            for (int tp = 0; tp < _tilePointPosPixel.Length; tp++) {
               GPoint tilePointPosXY = _tilePointPosXY[tp];

               // setzt core.TileRect
               GPoint tilePointPosPixel = _tilePointPosPixel[tp];
               core.Set_TileRectLocation(tilePointPosPixel);             // "Weltkoordinaten" des Tiles
               if (mapForceDoubleBuffer &&
                   mobileMode)
                  core.TileRect.Offset(core.RenderOffset);
               core.TileRect_OffsetNegative(core.CompensationOffset);

               bool found = false;
               Tile t = core.Matrix_GetTileWithNoLock(core.Zoom, tilePointPosXY);
               if (t.NotEmpty) {

                  foreach (GMapImage img in t.Overlays) {               // jedes Image (?) des Tiles
                     if (img != null && img.Img != null) {
                        if (!found)
                           found = true;

#if GMAP4SKIA
                        if (!img.IsParent) {

                           g.SKCanvas.DrawBitmap(img.Img, rectConvert(core.TileRect));

                        } else {
                           // TODO: move calculations to loader thread
                           g.SKCanvas.DrawBitmap(img.Img,
                                                 new SKRect(img.Xoff * (img.Img.Width / img.Ix),
                                                            img.Yoff * (img.Img.Height / img.Ix),
                                                            (img.Xoff + 1) * (img.Img.Width / img.Ix),
                                                            (img.Yoff + 1) * (img.Img.Height / img.Ix)),
                                                 rectConvert(core.TileRect));

                        }
                     }
#else
                        Image image = img.Img;
                        if (!img.IsParent) {
                           if (getScale() == 1 && !MapIsRotated) {
                              g.DrawImage(image, getCoreTileRectI());




                           } else {
                              g.DrawImage(image,
                                          getCoreTileRectI(),
                                          0,
                                          0,
                                          core.TileRect.Width,
                                          core.TileRect.Height,
                                          GraphicsUnit.Pixel,
                                          tileFlipXYAttributes);
                           }
                        } else {
                           // TODO: move calculations to loader thread
                           g.DrawImage(image,
                                       getCoreTileRectI(),
                                       img.Xoff * (image.Width / img.Ix),
                                       img.Yoff * (image.Height / img.Ix),
                                       image.Width / img.Ix,
                                       image.Height / img.Ix,
                                       GraphicsUnit.Pixel,
                                       tileFlipXYAttributes);
                        }
                     }
#endif
                  }

               } else if (MapFillEmptyTiles &&
                          MapProvider.Projection is MercatorProjection) {

                  int zoomOffset = 1;
                  var parentTile = Tile.Empty;
                  long ix = 0;

                  // suche ein Tile für geringeren Zoom
                  while (!parentTile.NotEmpty &&
                         zoomOffset < core.Zoom &&
                         zoomOffset <= MapLevelsKeepInMemory) {
                     ix = (long)Math.Pow(2, zoomOffset);
                     parentTile = core.Matrix_GetTileWithNoLock(core.Zoom - zoomOffset++,
                                                                new GPoint((int)(tilePointPosXY.X / ix),
                                                                           (int)(tilePointPosXY.Y / ix)));
                  }

                  // wenn gefunden, dann anzeigen
                  if (parentTile.NotEmpty) {
                     long xOff = Math.Abs(tilePointPosXY.X - parentTile.Pos.X * ix);
                     long yOff = Math.Abs(tilePointPosXY.Y - parentTile.Pos.Y * ix);
                     foreach (GMapImage img in parentTile.Overlays) {
                        if (img != null &&
                            img.Img != null &&
                            !img.IsParent) {
                           if (!found)
                              found = true;

                           var dst = getCoreTileRectI();
                           Image image = img.Img;

#if GMAP4SKIA
                           g.SKCanvas.DrawBitmap(image,
                                                 new SKRect(xOff * (image.Width / ix),
                                                            yOff * (image.Height / ix),
                                                            (xOff + 1) * (image.Width / ix),
                                                            (yOff + 1) * (image.Height / ix)),
                                                 rectConvert(core.TileRect));
#else
                           g.DrawImage(image,
                               dst,
                               xOff * (image.Width / ix),
                               yOff * (image.Height / ix),
                               image.Width / ix,
                               image.Height / ix,
                               GraphicsUnit.Pixel,
                               tileFlipXYAttributes);
#endif
                           g.FillRectangle(_selectedAreaFillBrush, dst);
                        }
                     }
                  }

               }

               // add text if tile is missing
               if (!found) {
                  Exception ex = core.GetException4FailedLoad(tilePointPosXY);
                  if (ex != null) {
                     g.FillRectangle(_emptyTileBrush, getCoreTileRectI());

                     g.DrawString("Exception: " + ex.Message,
                                  missingDataFont,
                                  Brushes.Red as SolidBrush,
                                  new RectangleF(core.TileRect.X + 11,
                                                 core.TileRect.Y + 11,
                                                 core.TileRect.Width - 11,
                                                 core.TileRect.Height - 11));

                     g.DrawString(MapEmptyTileText,
                                  missingDataFont,
                                  Brushes.Blue as SolidBrush,
                                  getCoreTileRectF(),
                                  centerFormat);

                     g.DrawRectangle(MapEmptyTileBordersPen, getCoreTileRectI());
                  }
               }

               if (MapShowTileGridLines) {
                  g.DrawRectangle(MapEmptyTileBordersPen, getCoreTileRectI());
#if GMAP4SKIA
                  g.DrawString((tilePointPosXY == core.CenterTileXYLocation ? "CENTER: " : "TILE: ") + tilePointPosXY.ToString(),
                               MapTileGridLinesFont,
                               Brushes.Red as SolidBrush,
                               new PointF(core.TileRect.X, core.TileRect.Y));

                  g.DrawString(tilePointPosPixel.ToString(),
                               MapTileGridLinesFont,
                               Brushes.Red as SolidBrush,
                               new PointF(core.TileRect.X, core.TileRect.Y + MapTileGridLinesFont.GetHeight()));
#else
                  g.DrawString((tilePointPosXY == core.CenterTileXYLocation ? "CENTER: " : "TILE: ") + tilePointPosXY.ToString(),
                               missingDataFont,
                               Brushes.Red,
                               getCoreTileRectF(),
                               centerFormat);
#endif
               }
            }
         } catch (Exception ex) {

            Log(">>> Exception in DrawMap(): " + ex.Message);

         } finally {
            core.Matrix_LeaveReadLock();
            core.TileDrawingListLock.ReleaseReaderLock();
         }
      }

      /// <summary>
      /// print some Core-Data to screen (only for testing)
      /// </summary>
      /// <param name="g"></param>
      void showCoreData(Graphics g) {
         g.ResetTransform();
         float h = MapEmptyTileFont.GetHeight();
         float y = 0;
         g.DrawString(string.Format("Core.ViewArea {0}", core.ViewArea), MapEmptyTileFont, Brushes.DarkBlue as SolidBrush, new PointF(0, y));
         y += h;
         g.DrawString(string.Format("Core.Position {0}", core.Position), MapEmptyTileFont, Brushes.DarkBlue as SolidBrush, new PointF(0, y));
         y += h;
         g.DrawString(string.Format("Core.PositionPixel {0}", core.PositionPixel), MapEmptyTileFont, Brushes.DarkBlue as SolidBrush, new PointF(0, y));
         y += h;
         g.DrawString(string.Format("Core.CompensationOffset {0}", core.CompensationOffset), MapEmptyTileFont, Brushes.DarkBlue as SolidBrush, new PointF(0, y));
         y += h;
         g.DrawString(string.Format("Core.CenterTileXYLocation {0}", core.CenterTileXYLocation), MapEmptyTileFont, Brushes.DarkBlue as SolidBrush, new PointF(0, y));
         y += h;
         g.DrawString(string.Format("Core.Width x Core.Height {0}x{1}", core.Width, core.Height), MapEmptyTileFont, Brushes.DarkBlue as SolidBrush, new PointF(0, y));
         y += h;
         g.DrawString(string.Format("Core.VWidth x Core.VHeight {0}x{1}", core.VWidth, core.VHeight), MapEmptyTileFont, Brushes.DarkBlue as SolidBrush, new PointF(0, y));
         y += h;
         g.DrawString(string.Format("Core.Zoom {0}", core.Zoom), MapEmptyTileFont, Brushes.DarkBlue as SolidBrush, new PointF(0, y));
         y += h;
         g.DrawString(string.Format("Core.ScaleX {0}, Core.ScaleY {1}", core.ScaleX, core.ScaleY), MapEmptyTileFont, Brushes.DarkBlue as SolidBrush, new PointF(0, y));
         y += h;
         g.DrawString(string.Format("Core.Bearing {0}", core.Bearing), MapEmptyTileFont, Brushes.DarkBlue as SolidBrush, new PointF(0, y));
         y += h;
      }

      RectangleF getCoreTileRectF() => new RectangleF(core.TileRect.X,
                                                      core.TileRect.Y,
                                                      core.TileRect.Width,
                                                      core.TileRect.Height);

      Rectangle getCoreTileRectI() => new Rectangle((int)core.TileRect.X,
                                                    (int)core.TileRect.Y,
                                                    (int)core.TileRect.Width,
                                                    (int)core.TileRect.Height);

#if WITHORGCODE

      void drawSimpleScale(Graphics g, int top, int right, int bottom, int left, string caption) {
         g.DrawLine(MapScalePenBorder, left, top, left, bottom);
         g.DrawLine(MapScalePenBorder, left, bottom, right, bottom);
         g.DrawLine(MapScalePenBorder, right, bottom, right, top);

         g.DrawLine(MapScalePen, left, top, left, bottom);
         g.DrawLine(MapScalePen, left, bottom, right, bottom);
         g.DrawLine(MapScalePen, right, bottom, right, top);

         g.DrawString(caption, scaleFont, Brushes.Black, right + 3, top - 5);
      }

#endif


      /// <summary>
      /// apply transformation if in rotation mode
      /// </summary>
      GPoint applyRotationInversion(int x, int y) {
         var ret = new GPoint(x, y);
         if (MapIsRotated)
            applyRotation(ret);
         return ret;
      }

      /// <summary>
      /// Matrix <see cref="rotationMatrixInvert"/> anwenden
      /// </summary>
      /// <param name="xclient"></param>
      /// <param name="yclient"></param>
      void applyRotationInversion(ref int xclient, ref int yclient) {
         if (MapIsRotated) {
            var tt = new[] { new Point(xclient, yclient) };
            rotationMatrixInvert.TransformPoints(tt);
            var f = tt[0];
            xclient = f.X;
            yclient = f.Y;
         }
      }

      /// <summary>
      /// Matrix <see cref="rotationMatrix"/> anwenden
      /// </summary>
      /// <param name="ptClient"></param>
      void applyRotation(GPoint ptClient) {
         if (MapIsRotated) {
            var tt = new[] { new Point((int)ptClient.X, (int)ptClient.Y) };
            rotationMatrix.TransformPoints(tt);
            var f = tt[0];
            ptClient.X = f.X;
            ptClient.Y = f.Y;
         }
      }


#if WITHORGCODE

      /// <summary>
      /// apply transformation if in rotation mode
      /// </summary>
      GPoint applyRotation(int x, int y) {
         var ret = new GPoint(x, y);

         if (MapIsRotated) {
            var tt = new[] { new Point(x, y) };
            rotationMatrix.TransformPoints(tt);
            var f = tt[0];

            ret.X = f.X;
            ret.Y = f.Y;
         }

         return ret;
      }

#endif

      /// <summary>
      /// updates rotation matrix
      /// </summary>
      void updateRotationMatrix() {
         var center = new PointF(core.Width / 2, core.Height / 2);

         rotationMatrix.Reset();
         rotationMatrix.RotateAt(-MapBearing, center);

         rotationMatrixInvert.Reset();
         rotationMatrixInvert.RotateAt(-MapBearing, center);
         rotationMatrixInvert.Invert();
      }

      void setCursorHandOnEnter() {
#if !GMAP4SKIA
         if (_overObjectCount <= 0 && Cursor != Cursors.Hand) {
            _overObjectCount = 0;
            cursorBefore = Cursor;
            Cursor = Cursors.Hand;
         }
#endif
      }


      protected void Log(string txt) => Debug.WriteLine(txt);

      #endregion

      #region Internal-Funktionen

#if !DESIGN
      /// <summary>
      ///     enque built-in thread safe invalidation (only for internal use)
      /// </summary>
      internal void MapCoreInvalidate() {
         core.StartRefresh();
#if GMAP4SKIA
         //MainThread.BeginInvokeOnMainThread(() => InvalidateSurface());
         //InvalidateSurface();
#endif
      }
#endif

      /// <summary>
      ///     updates markers local position (only for internal use)
      /// </summary>
      /// <param name="marker"></param>
      internal void MapUpdateMarkerLocalPosition(GMapMarker marker) {
         GPoint p = core.FromLatLngToLocal(marker.Position, getScale(), true);
         marker.LocalPosition = new Point((int)(p.X + marker.Offset.X), (int)(p.Y + marker.Offset.Y));
      }

      /// <summary>
      ///     updates tracks local position (only for internal use)
      /// </summary>
      /// <param name="track"></param>
      internal void MapUpdateTrackLocalPosition(GMapTrack track) {
         track.LocalPoints.Clear();
         for (int i = 0; i < track.Points.Count; i++) {
            GPoint p = core.FromLatLngToLocal(track.Points[i], getScale(), true);
            track.LocalPoints.Add(p);
         }
         track.UpdateVisualParts();
      }

      /// <summary>
      ///     updates polygons local position (only for internal use)
      /// </summary>
      /// <param name="polygon"></param>
      internal void MapUpdatePolygonLocalPosition(GMapPolygon polygon) {
         polygon.LocalPoints.Clear();
         for (int i = 0; i < polygon.Points.Count; i++) {
            GPoint p = core.FromLatLngToLocal(polygon.Points[i], getScale(), true);
            polygon.LocalPoints.Add(p);
         }
         polygon.UpdateGraphicsPath();
      }

      internal void RestoreCursorOnLeave() {
#if !GMAP4SKIA
         if (_overObjectCount <= 0 && cursorBefore != null) {
            _overObjectCount = 0;
            Cursor = cursorBefore;
            cursorBefore = null;
         }
#endif
      }

      #endregion

#if GMAP4SKIA

      #region static Konvertierungen Xamarin <-> Skia (Control-Koordinaten)

      public static float XamarinX2SkiaX(double x) {
         return (float)(x * Xamarin.Essentials.DeviceDisplay.MainDisplayInfo.Density);
      }

      public static float XamarinY2SkiaY(double y) {
         return (float)(y * Xamarin.Essentials.DeviceDisplay.MainDisplayInfo.Density);
      }

      public static double SkiaX2XamarinX(double x) {
         return x / Xamarin.Essentials.DeviceDisplay.MainDisplayInfo.Density;
      }

      public static double SkiaY2XamarinY(double y) {
         return y / Xamarin.Essentials.DeviceDisplay.MainDisplayInfo.Density;
      }

      /// <summary>
      /// rechnet einen Xamarin-Punkt in einen Skia-Punkt um
      /// </summary>
      /// <param name="pt"></param>
      /// <returns></returns>
      public static SKPoint Xamarin2Skia(Xamarin.Forms.Point pt) {
         return new SKPoint(XamarinX2SkiaX(pt.X),
                            XamarinY2SkiaY(pt.Y));
      }

      public static Xamarin.Forms.Point Xamarin2Skia(SKPoint pt) {
         return new Xamarin.Forms.Point(SkiaX2XamarinX(pt.X),
                                        SkiaY2XamarinY(pt.Y));
      }

      #endregion

      public void MapServiceStart(double lon,
                                  double lat,
                                  string cachepath,
                                  int zoom = 12,
                                  ScaleModes scaleModes = ScaleModes.Fractional) {
         if (!IsDesignerHosted &&
             !MapServiceIsReady) {

            if (!string.IsNullOrEmpty(cachepath)) {
               if (!Directory.Exists(cachepath))
                  Directory.CreateDirectory(cachepath);
               MapCacheLocation = cachepath;
            }
            GMaps.Instance.Mode = string.IsNullOrEmpty(cachepath) ?
                                       AccessMode.ServerOnly :
                                       AccessMode.ServerAndCache;

            OnLoad(new EventArgs());

            MapMinZoom = 0;
            MapMaxZoom = 24;
            MapZoom = zoom;
            MapScaleMode = scaleModes;

            MapPosition = new PointLatLng(lat, lon);
         }
      }

      /// <summary>
      /// beendet den Mapservice
      /// </summary>
      public void MapServiceEnd() {
         if (MapServiceIsReady) {
            core.OnMapClose(); // Dispose
         }
      }

      #region simulating Mouse-Action for None-Windows-System

      /// <summary>
      /// Ruft die Position des Mauszeigers in Bildschirmkoordinaten ab. (z.Z. nicht verwendet)
      /// </summary>
      static System.Drawing.Point MousePosition { get; set; }

      enum MouseAction {
         MouseDown,
         MouseUp,
         //MouseClick,
         //MouseDoubleClick,
         MouseMove,
         //MouseWheel,
      }

      /// <summary>
      /// setzt die Mauspos. als Control-Koordinaten! (i.A. im Zusammenhang mit Touch-Ereignissen)
      /// </summary>
      /// <param name="clientx"></param>
      /// <param name="clienty"></param>
      static void simulateMousePosition(int clientx, int clienty) {
         MousePosition = new Point(clientx, clienty);
      }

      /// <summary>
      /// zum Simulieren einer Mausaktion (i.A. im Zusammenhang mit Touch-Ereignissen)
      /// </summary>
      /// <param name="action"></param>
      /// <param name="button"></param>
      /// <param name="clientx"></param>
      /// <param name="clienty"></param>
      /// <param name="delta"></param>
      Task simulateMouseAction(MouseAction action, MouseButtons button, int clientx, int clienty, int delta) {
         return Task.Run(() => {
            simulateMousePosition(clientx, clienty);
            MouseEventArgs ea = new MouseEventArgs(button, clientx, clienty, delta);
            switch (action) {
               case MouseAction.MouseDown: OnMouseDown(ea); break;
               case MouseAction.MouseUp: OnMouseUp(ea); break;
               case MouseAction.MouseMove: OnMouseMove(ea); break;
            }
         });
      }

      /// <summary>
      /// Beginn der Kartenverschiebung
      /// </summary>
      /// <param name="startpt"></param>
      public Task MapDragStart(Xamarin.Forms.Point startpt) {
         return simulateMouseAction(MouseAction.MouseDown,
                                    MouseButtons.Right,
                                    (int)XamarinX2SkiaX(startpt.X),
                                    (int)XamarinY2SkiaY(startpt.Y),
                                    0);
      }

      /// <summary>
      /// Kartenverschiebung
      /// </summary>
      /// <param name="actualpt"></param>
      public Task MapDrag(Xamarin.Forms.Point actualpt) {
         return simulateMouseAction(MouseAction.MouseMove,
                                    MouseButtons.Right,
                                    (int)XamarinX2SkiaX(actualpt.X),
                                    (int)XamarinY2SkiaY(actualpt.Y),
                                    0);
      }

      /// <summary>
      /// Kartenverschiebung beendet
      /// </summary>
      /// <param name="endpt"></param>
      public Task MapDragEnd(Xamarin.Forms.Point endpt) {
         return simulateMouseAction(MouseAction.MouseUp,
                                    MouseButtons.Right,
                                    (int)XamarinX2SkiaX(endpt.X),
                                    (int)XamarinY2SkiaY(endpt.Y),
                                    0);
      }

      /// <summary>
      /// verschiebt die Karte (i.A. um eine größere Entfernung)
      /// </summary>
      /// <param name="deltalon"></param>
      /// <param name="deltalat"></param>
      public Task MapMove(double deltalon, double deltalat) {
         return Task.Run(() => {
            MapPosition = new PointLatLng(MapPosition.Lat + deltalat,
                                          MapPosition.Lng - deltalon);
         });
      }

      #endregion

      SKRect rectConvert(GRect rect) {
         return new SKRect(rect.Left, rect.Top, rect.Right, rect.Bottom);
      }


      /// <summary>
      /// Ersatz für den Windows Control-Font
      /// </summary>
      public Font Font { get; protected set; }

      int _width, _height;

      /// <summary>
      /// Ruft die Höhe des Steuerelements ab (in Skia-Koordinaten)
      /// </summary>
      public new int Height {
         get => _height;
         set => _height = value;
      }

      /// <summary>
      /// Ruft die Breite des Steuerelements ab (in Skia-Koordinaten)
      /// </summary>
      public new int Width {
         get => _width;
         set => _width = value;
      }

      public int ClientSizeWidth => Width;

      public int ClientSizeHeight => Height;

      /// <summary>
      /// Setzt den Eingabefokus auf das Steuerelement.
      /// </summary>
      public new void Focus() => base.Focus();

      /// <summary>
      /// Ruft einen Wert ab, der angibt, ob dem Steuerelement ein Handle zugeordnet ist.
      /// </summary>
      public bool IsHandleCreated => base.Width > 0 && base.Height > 0;

      /// <summary>
      /// Ruft einen Wert ab, mit dem angegeben wird, ob das Steuerelement und alle untergeordneten Steuerelemente angezeigt werden, oder legt diesen Wert fest.
      /// </summary>
      public bool Visible => base.IsVisible;

      /// <summary>
      /// Ruft einen Wert ab, der angibt, welche der Zusatztasten (Umschalttaste, STRG und ALT) gedrückt ist.
      /// <para>Gibt es bei Android nicht.</para>
      /// </summary>
      public System.Windows.Forms.Keys ModifierKeys => System.Windows.Forms.Keys.None;

#endif
   }
}
